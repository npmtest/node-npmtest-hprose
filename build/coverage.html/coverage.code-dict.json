{"/home/travis/build/npmtest/node-npmtest-hprose/test.js":"/* istanbul instrument in package npmtest_hprose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-hprose/lib.npmtest_hprose.js":"/* istanbul instrument in package npmtest_hprose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_hprose = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_hprose = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-hprose/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-hprose && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_hprose */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_hprose\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_hprose.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_hprose.rollup.js'] =\n            local.assetsDict['/assets.npmtest_hprose.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_hprose.__dirname + '/lib.npmtest_hprose.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/hprose.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose.js                                              *\n *                                                        *\n * hprose for Node.js.                                    *\n *                                                        *\n * LastModified: Sep 30, 2016                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nglobal.hprose = global.hprose || Object.create(null);\n\nrequire('./common/Helper.js');\nrequire('./common/Polyfill.js');\nrequire('./common/HarmonyMaps.js');\nrequire('./common/Future.js');\nrequire('./common/ResultMode.js');\n\nrequire('./io/BytesIO.js');\nrequire('./io/ClassManager.js');\nrequire('./io/Tags.js');\nrequire('./io/Writer.js');\nrequire('./io/Reader.js');\nrequire('./io/Formatter.js');\n\nrequire('./client/Client.js');\nrequire('./client/HttpClient.js');\nrequire('./client/SocketClient.js');\nrequire('./client/WebSocketClient.js');\n\nrequire('./server/Service.js');\nrequire('./server/HttpService.js');\nrequire('./server/HttpServer.js');\nrequire('./server/SocketService.js');\nrequire('./server/SocketServer.js');\nrequire('./server/WebSocketService.js');\nrequire('./server/WebSocketServer.js');\nrequire('./server/Server.js');\n\nrequire('./filter/JSONRPCClientFilter.js');\nrequire('./filter/JSONRPCServiceFilter.js');\n\nrequire('./utils/regenerator-runtime.js');\n\nglobal.HproseCompleter = global.hprose.Completer;\nglobal.HproseFuture = global.hprose.Future;\nglobal.HproseResultMode = global.hprose.ResultMode;\n\nglobal.HproseBytesIO = global.hprose.BytesIO;\nglobal.HproseClassManager = global.hprose.ClassManager;\nglobal.HproseTags = global.hprose.Tags;\nglobal.HproseWriter = global.hprose.Writer;\nglobal.HproseRawReader = global.hprose.RawReader;\nglobal.HproseReader = global.hprose.Reader;\nglobal.HproseFormatter = global.hprose.Formatter;\n\nglobal.HproseClient = global.hprose.Client;\nglobal.HproseHttpClient = global.hprose.HttpClient;\nglobal.HproseSocketClient = global.hprose.SocketClient;\nglobal.HproseTcpClient = global.hprose.TcpClient;\nglobal.HproseUnixClient = global.hprose.UnixClient;\nglobal.HproseWebSocketClient = global.hprose.WebSocketClient;\n\nglobal.HproseService = global.hprose.Service;\nglobal.HproseServer = global.hprose.Server;\nglobal.HproseHttpService = global.hprose.HttpService;\nglobal.HproseHttpServer = global.hprose.HttpServer;\nglobal.HproseSocketService = global.hprose.SocketService;\nglobal.HproseSocketServer = global.hprose.SocketServer;\nglobal.HproseTcpServer = global.hprose.TcpServer;\nglobal.HproseUnixServer = global.hprose.UnixServer;\nglobal.HproseWebSocketService = global.hprose.WebSocketService;\nglobal.HproseWebSocketServer = global.hprose.WebSocketServer;\n\nglobal.HproseJSONRPCClientFilter = global.hprose.JSONRPCClientFilter;\nglobal.HproseJSONRPCServiceFilter = global.hprose.JSONRPCServiceFilter;\n\nglobal.hprose.common = {\n    Completer: global.hprose.Completer,\n    Future: global.hprose.Future,\n    ResultMode: global.hprose.ResultMode\n};\n\nglobal.hprose.io = {\n    BytesIO: global.hprose.BytesIO,\n    ClassManager: global.hprose.ClassManager,\n    Tags: global.hprose.Tags,\n    RawReader: global.hprose.RawReader,\n    Reader: global.hprose.Reader,\n    Writer: global.hprose.Writer,\n    Formatter: global.hprose.Formatter\n};\n\nglobal.hprose.client = {\n    Client: global.hprose.Client,\n    HttpClient: global.hprose.HttpClient,\n    SocketClient: global.hprose.SocketClient,\n    TcpClient: global.hprose.TcpClient,\n    UnixClient: global.hprose.UnixClient,\n    WebSocketClient: global.hprose.WebSocketClient\n};\n\nglobal.hprose.server = {\n    Service: global.hprose.Service,\n    Server: global.hprose.Server,\n    HttpService: global.hprose.HttpService,\n    HttpServer: global.hprose.HttpServer,\n    SocketService: global.hprose.SocketService,\n    SocketServer: global.hprose.SocketServer,\n    TcpServer: global.hprose.TcpServer,\n    UnixServer: global.hprose.UnixServer,\n    WebSocketService: global.hprose.WebSocketService,\n    WebSocketServer: global.hprose.WebSocketServer\n};\n\nglobal.hprose.filter = {\n    JSONRPCClientFilter: global.hprose.JSONRPCClientFilter,\n    JSONRPCServiceFilter: global.hprose.JSONRPCServiceFilter\n};\n\nmodule.exports = global.hprose;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/common/Helper.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/common/Helper.js                                *\n *                                                        *\n * Hprose Helper for Node.js.                             *\n *                                                        *\n * LastModified: Oct 12, 2016                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n(function() {\n    'use strict';\n\n    function generic(method) {\n        if (typeof method !== \"function\") {\n            throw new TypeError(method + \" is not a function\");\n        }\n        return function(context) {\n            return method.apply(context, Array.prototype.slice.call(arguments, 1));\n        };\n    }\n\n    var arrayLikeObjectArgumentsEnabled = true;\n\n    try {\n        String.fromCharCode.apply(String, new Uint8Array([1]));\n    }\n    catch (e) {\n        arrayLikeObjectArgumentsEnabled = false;\n    }\n\n    function toArray(arrayLikeObject) {\n        var n = arrayLikeObject.length;\n        var a = new Array(n);\n        for (var i = 0; i < n; ++i) {\n            a[i] = arrayLikeObject[i];\n        }\n        return a;\n    }\n\n    var getCharCodes = arrayLikeObjectArgumentsEnabled ? function(bytes) { return bytes; } : toArray;\n\n    function toBinaryString(bytes) {\n        if (bytes instanceof ArrayBuffer) {\n            bytes = new Uint8Array(bytes);\n        }\n        var n = bytes.length;\n        if (n < 0xFFFF) {\n            return String.fromCharCode.apply(String, getCharCodes(bytes));\n        }\n        var remain = n & 0x7FFF;\n        var count = n >> 15;\n        var a = new Array(remain ? count + 1 : count);\n        for (var i = 0; i < count; ++i) {\n            a[i] = String.fromCharCode.apply(String, getCharCodes(bytes.subarray(i << 15, (i + 1) << 15)));\n        }\n        if (remain) {\n            a[count] = String.fromCharCode.apply(String, getCharCodes(bytes.subarray(count << 15, n)));\n        }\n        return a.join('');\n    }\n\n    function toUint8Array(bs) {\n        var n = bs.length;\n        var data = new Uint8Array(n);\n        for (var i = 0; i < n; i++) {\n            data[i] = bs.charCodeAt(i) & 0xFF;\n        }\n        return data;\n    }\n\n    var isObjectEmpty = function (obj) {\n        if (obj) {\n            var prop;\n            for (prop in obj) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    global.hprose.generic = generic;\n    global.hprose.toBinaryString = toBinaryString;\n    global.hprose.toUint8Array = toUint8Array;\n    global.hprose.toArray = toArray;\n    global.hprose.isObjectEmpty = isObjectEmpty;\n\n})();\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/common/Polyfill.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * Polyfill.js                                            *\n *                                                        *\n * Polyfill for Node.js.                                  *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n/* Function */\nif (!Function.prototype.bind) {\n    Object.defineProperty(Function.prototype, 'bind', { value: function(oThis) {\n        if (typeof this !== 'function') {\n            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n        }\n        var aArgs   = Array.prototype.slice.call(arguments, 1),\n            toBind = this,\n            NOP    = function() {},\n            bound  = function() {\n                return toBind.apply(this instanceof NOP ? this : oThis,\n                        aArgs.concat(Array.prototype.slice.call(arguments)));\n            };\n        if (this.prototype) {\n            NOP.prototype = this.prototype;\n        }\n        bound.prototype = new NOP();\n        return bound;\n    } });\n}\n/* Array */\nif (!Array.prototype.includes) {\n    Object.defineProperty(Array.prototype, 'includes', { value: function(searchElement /*, fromIndex*/ ) {\n        var O = Object(this);\n        var len = parseInt(O.length, 10) || 0;\n        if (len === 0) {\n            return false;\n        }\n        var n = parseInt(arguments[1], 10) || 0;\n        var k;\n        if (n >= 0) {\n            k = n;\n        }\n        else {\n            k = len + n;\n            if (k < 0) { k = 0; }\n        }\n        var currentElement;\n        while (k < len) {\n            currentElement = O[k];\n            if (searchElement === currentElement ||\n                (searchElement !== searchElement && currentElement !== currentElement)) { // NaN !== NaN\n                return true;\n            }\n            k++;\n        }\n        return false;\n    } });\n}\nif (!Array.prototype.find) {\n    Object.defineProperty(Array.prototype, 'find', { value: function(predicate) {\n        if (this === null || this === undefined) {\n            throw new TypeError('Array.prototype.find called on null or undefined');\n        }\n        if (typeof predicate !== 'function') {\n            throw new TypeError('predicate must be a function');\n        }\n        var list = Object(this);\n        var length = list.length >>> 0;\n        var thisArg = arguments[1];\n        var value;\n        for (var i = 0; i < length; i++) {\n            value = list[i];\n            if (predicate.call(thisArg, value, i, list)) {\n                return value;\n            }\n        }\n        return undefined;\n    } });\n}\nif (!Array.prototype.findIndex) {\n    Object.defineProperty(Array.prototype, 'findIndex', { value: function(predicate) {\n        if (this === null || this === undefined) {\n            throw new TypeError('Array.prototype.findIndex called on null or undefined');\n        }\n        if (typeof predicate !== 'function') {\n            throw new TypeError('predicate must be a function');\n        }\n        var list = Object(this);\n        var length = list.length >>> 0;\n        var thisArg = arguments[1];\n        var value;\n\n        for (var i = 0; i < length; i++) {\n            value = list[i];\n            if (predicate.call(thisArg, value, i, list)) {\n                return i;\n            }\n        }\n        return -1;\n    } });\n}\nif (!Array.prototype.fill) {\n    Object.defineProperty(Array.prototype, 'fill', { value: function(value) {\n        if (this === null || this === undefined) {\n            throw new TypeError('this is null or not defined');\n        }\n        var O = Object(this);\n        var len = O.length >>> 0;\n        var start = arguments[1];\n        var relativeStart = start >> 0;\n        var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n        var end = arguments[2];\n        var relativeEnd = end === undefined ? len : end >> 0;\n        var f = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n\n        while (k < f) {\n            O[k] = value;\n            k++;\n        }\n        return O;\n    } });\n}\nif (!Array.prototype.copyWithin) {\n    Object.defineProperty(Array.prototype, 'copyWithin', { value: function(target, start/*, end*/) {\n        if (this === null || this === undefined) {\n            throw new TypeError('this is null or not defined');\n        }\n        var O = Object(this);\n        var len = O.length >>> 0;\n        var relativeTarget = target >> 0;\n        var to = relativeTarget < 0 ? Math.max(len + relativeTarget, 0) : Math.min(relativeTarget, len);\n        var relativeStart = start >> 0;\n        var from = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);\n        var end = arguments[2];\n        var relativeEnd = end === undefined ? len : end >> 0;\n        var f = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);\n        var count = Math.min(f - from, len - to);\n        var direction = 1;\n        if (from < to && to < (from + count)) {\n            direction = -1;\n            from += count - 1;\n            to += count - 1;\n        }\n        while (count > 0) {\n            if (from in O) {\n                O[to] = O[from];\n            }\n            else {\n                delete O[to];\n            }\n            from += direction;\n            to += direction;\n            count--;\n        }\n        return O;\n    } });\n}\nif (!Array.from) {\n    Object.defineProperty(Array, 'from', { value: (function() {\n        var toStr = Object.prototype.toString;\n        var isCallable = function(fn) {\n            return typeof fn === 'function' || toStr.call(fn) === '[object Function]';\n        };\n        var toInteger = function(value) {\n            var number = Number(value);\n            if (isNaN(number)) { return 0; }\n            if (number === 0 || !isFinite(number)) { return number; }\n            return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n        };\n        var maxSafeInteger = Math.pow(2, 53) - 1;\n        var toLength = function(value) {\n            var len = toInteger(value);\n            return Math.min(Math.max(len, 0), maxSafeInteger);\n        };\n\n        return function(arrayLike/*, mapFn, thisArg */) {\n            var C = this;\n            var items = Object(arrayLike);\n            if (arrayLike === null || arrayLike === undefined) {\n                throw new TypeError(\"Array.from requires an array-like object - not null or undefined\");\n            }\n            var mapFn = arguments.length > 1 ? arguments[1] : void undefined;\n            var T;\n            if (typeof mapFn !== 'undefined') {\n                if (!isCallable(mapFn)) {\n                    throw new TypeError('Array.from: when provided, the second argument must be a function');\n                }\n                if (arguments.length > 2) {\n                    T = arguments[2];\n                }\n            }\n            var len = toLength(items.length);\n            var A = isCallable(C) ? Object(new C(len)) : new Array(len);\n            var k = 0;\n            var kValue;\n            while (k < len) {\n                kValue = items[k];\n                if (mapFn) {\n                    A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);\n                }\n                else {\n                    A[k] = kValue;\n                }\n                k += 1;\n            }\n            A.length = len;\n            return A;\n        };\n    }()) });\n}\nif (!Array.of) {\n    Object.defineProperty(Array, 'of', { value: function() {\n        return Array.prototype.slice.call(arguments);\n    } });\n}\n/* String */\nif (!String.prototype.startsWith) {\n    Object.defineProperty(String.prototype, 'startsWith', { value: function(searchString, position){\n        position = position || 0;\n        return this.substr(position, searchString.length) === searchString;\n    } });\n}\nif (!String.prototype.endsWith) {\n    Object.defineProperty(String.prototype, 'endsWith', { value: function(searchString, position) {\n        var subjectString = this.toString();\n        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n            position = subjectString.length;\n        }\n        position -= searchString.length;\n        var lastIndex = subjectString.indexOf(searchString, position);\n        return lastIndex !== -1 && lastIndex === position;\n    } });\n}\nif (!String.prototype.includes) {\n    Object.defineProperty(String.prototype, 'includes', { value: function() {\n        if (typeof arguments[1] === \"number\") {\n            if (this.length < arguments[0].length + arguments[1].length) {\n                return false;\n            }\n            else {\n                return this.substr(arguments[1], arguments[0].length) === arguments[0];\n            }\n        }\n        else {\n            return String.prototype.indexOf.apply(this, arguments) !== -1;\n        }\n    } });\n}\nif (!String.prototype.repeat) {\n    Object.defineProperty(String.prototype, 'repeat', { value: function(count) {\n        var str = this.toString();\n        count = +count;\n        if (count !== count) {\n            count = 0;\n        }\n        if (count < 0) {\n            throw new RangeError('repeat count must be non-negative');\n        }\n        if (count === Infinity) {\n            throw new RangeError('repeat count must be less than infinity');\n        }\n        count = Math.floor(count);\n        if (str.length === 0 || count === 0) {\n            return '';\n        }\n        // Ensuring count is a 31-bit integer allows us to heavily optimize the\n        // main part. But anyway, most current (August 2014) browsers can't handle\n        // strings 1 << 28 chars or longer, so:\n        if (str.length * count >= 1 << 28) {\n          throw new RangeError('repeat count must not overflow maximum string size');\n        }\n        var rpt = '';\n        for (;;) {\n            if ((count & 1) === 1) {\n                rpt += str;\n            }\n            count >>>= 1;\n            if (count === 0) {\n                break;\n            }\n            str += str;\n        }\n        // Could we try:\n        // return Array(count + 1).join(this);\n        return rpt;\n    } });\n}\nif (!String.prototype.trim) {\n    Object.defineProperty(String.prototype, 'trim', { value: function() {\n        return this.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '');\n    } });\n}\nif (!String.prototype.trimLeft) {\n    Object.defineProperty(String.prototype, 'trimLeft', { value: function() {\n        return this.toString().replace(/^[\\s\\xa0]+/, '');\n    } });\n}\nif (!String.prototype.trimRight) {\n    Object.defineProperty(String.prototype, 'trimRight', { value: function() {\n        return this.toString().replace(/[\\s\\xa0]+$/, '');\n    } });\n}\n/* Object */\nif (!Object.keys) {\n    Object.defineProperty(Object, 'keys', { value: (function () {\n        var hasOwnProperty = Object.prototype.hasOwnProperty,\n            hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),\n            dontEnums = [\n                'toString',\n                'toLocaleString',\n                'valueOf',\n                'hasOwnProperty',\n                'isPrototypeOf',\n                'propertyIsEnumerable',\n                'constructor'\n            ],\n            dontEnumsLength = dontEnums.length;\n        return function (obj) {\n            if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {\n                throw new TypeError('Object.keys called on non-object');\n            }\n            var result = [];\n            for (var prop in obj) {\n                if (hasOwnProperty.call(obj, prop)) {\n                    result.push(prop);\n                }\n            }\n            if (hasDontEnumBug) {\n                for (var i=0; i < dontEnumsLength; i++) {\n                    if (hasOwnProperty.call(obj, dontEnums[i])) {\n                        result.push(dontEnums[i]);\n                    }\n                }\n            }\n            return result;\n        };\n    })() });\n}\n/* Generic methods */\nvar generic = global.hprose.generic;\n\nfunction genericMethods(obj, properties) {\n    var proto = obj.prototype;\n    for (var i = 0, len = properties.length; i < len; i++) {\n        var property = properties[i];\n        var method = proto[property];\n        if (typeof method === 'function' && typeof obj[property] === 'undefined') {\n            Object.defineProperty(obj, property, { value: generic(method) });\n        }\n    }\n}\ngenericMethods(Array, [\n    \"pop\",\n    \"push\",\n    \"reverse\",\n    \"shift\",\n    \"sort\",\n    \"splice\",\n    \"unshift\",\n    \"concat\",\n    \"join\",\n    \"slice\",\n    \"indexOf\",\n    \"lastIndexOf\",\n    \"filter\",\n    \"forEach\",\n    \"every\",\n    \"map\",\n    \"some\",\n    \"reduce\",\n    \"reduceRight\",\n    \"includes\",\n    \"find\",\n    \"findIndex\"\n]);\ngenericMethods(String, [\n    'quote',\n    'substring',\n    'toLowerCase',\n    'toUpperCase',\n    'charAt',\n    'charCodeAt',\n    'indexOf',\n    'lastIndexOf',\n    'include',\n    'startsWith',\n    'endsWith',\n    'repeat',\n    'trim',\n    'trimLeft',\n    'trimRight',\n    'toLocaleLowerCase',\n    'toLocaleUpperCase',\n    'match',\n    'search',\n    'replace',\n    'split',\n    'substr',\n    'concat',\n    'slice'\n]);\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/common/HarmonyMaps.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/common/HarmonyMaps.js                           *\n *                                                        *\n * Harmony Maps for Node.js.                              *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n(function() {\n    'use strict';\n\n    var hasWeakMap = 'WeakMap' in global;\n    var hasMap = 'Map' in global;\n    var hasForEach = true;\n\n    if (hasMap) {\n        hasForEach = 'forEach' in new global.Map();\n    }\n\n    if (hasWeakMap && hasMap && hasForEach) { return; }\n\n    var namespaces = Object.create(null);\n    var count = 0;\n    var reDefineValueOf = function (obj) {\n        var privates = Object.create(null);\n        var baseValueOf = obj.valueOf;\n        Object.defineProperty(obj, 'valueOf', {\n            value: function (namespace, n) {\n                    if ((this === obj) &&\n                        (n in namespaces) &&\n                        (namespaces[n] === namespace)) {\n                        if (!(n in privates)) {\n                            privates[n] = Object.create(null);\n                        }\n                        return privates[n];\n                    }\n                    else {\n                        return baseValueOf.apply(this, arguments);\n                    }\n                },\n            writable: true,\n            configurable: true,\n            enumerable: false\n        });\n    };\n\n    if (!hasWeakMap) {\n        global.WeakMap = function WeakMap() {\n            var namespace = Object.create(null);\n            var n = count++;\n            namespaces[n] = namespace;\n            var map = function (key) {\n                if (key !== Object(key)) {\n                    throw new Error('value is not a non-null object');\n                }\n                var privates = key.valueOf(namespace, n);\n                if (privates !== key.valueOf()) {\n                    return privates;\n                }\n                reDefineValueOf(key);\n                return key.valueOf(namespace, n);\n            };\n            var m = Object.create(WeakMap.prototype, {\n                get: {\n                    value: function (key) {\n                        return map(key).value;\n                    }\n                },\n                set: {\n                    value: function (key, value) {\n                        map(key).value = value;\n                    }\n                },\n                has: {\n                    value: function (key) {\n                        return 'value' in map(key);\n                    }\n                },\n                'delete': {\n                    value: function (key) {\n                        return delete map(key).value;\n                    }\n                },\n                clear: {\n                    value: function () {\n                        delete namespaces[n];\n                        n = count++;\n                        namespaces[n] = namespace;\n                    }\n                }\n            });\n            if (arguments.length > 0 && Array.isArray(arguments[0])) {\n                var iterable = arguments[0];\n                for (var i = 0, len = iterable.length; i < len; i++) {\n                    m.set(iterable[i][0], iterable[i][1]);\n                }\n            }\n            return m;\n        };\n    }\n\n    if (!hasMap) {\n        var objectMap = function () {\n            var namespace = Object.create(null);\n            var n = count++;\n            var nullMap = Object.create(null);\n            namespaces[n] = namespace;\n            var map = function (key) {\n                if (key === null) { return nullMap; }\n                var privates = key.valueOf(namespace, n);\n                if (privates !== key.valueOf()) { return privates; }\n                reDefineValueOf(key);\n                return key.valueOf(namespace, n);\n            };\n            return {\n                get: function (key) { return map(key).value; },\n                set: function (key, value) { map(key).value = value; },\n                has: function (key) { return 'value' in map(key); },\n                'delete': function (key) { return delete map(key).value; },\n                clear: function () {\n                    delete namespaces[n];\n                    n = count++;\n                    namespaces[n] = namespace;\n                }\n            };\n        };\n        var noKeyMap = function () {\n            var map = Object.create(null);\n            return {\n                get: function () { return map.value; },\n                set: function (_, value) { map.value = value; },\n                has: function () { return 'value' in map; },\n                'delete': function () { return delete map.value; },\n                clear: function () { map = Object.create(null); }\n            };\n        };\n        var scalarMap = function () {\n            var map = Object.create(null);\n            return {\n                get: function (key) { return map[key]; },\n                set: function (key, value) { map[key] = value; },\n                has: function (key) { return key in map; },\n                'delete': function (key) { return delete map[key]; },\n                clear: function () { map = Object.create(null); }\n            };\n        };\n        global.Map = function Map() {\n            var map = {\n                'number': scalarMap(),\n                'string': scalarMap(),\n                'boolean': scalarMap(),\n                'object': objectMap(),\n                'function': objectMap(),\n                'unknown': objectMap(),\n                'undefined': noKeyMap(),\n                'null': noKeyMap()\n            };\n            var size = 0;\n            var keys = [];\n            var m = Object.create(Map.prototype, {\n                size: {\n                    get : function () { return size; }\n                },\n                get: {\n                    value: function (key) {\n                        return map[typeof(key)].get(key);\n                    }\n                },\n                set: {\n                    value: function (key, value) {\n                        if (!this.has(key)) {\n                            keys.push(key);\n                            size++;\n                        }\n                        map[typeof(key)].set(key, value);\n                    }\n                },\n                has: {\n                    value: function (key) {\n                        return map[typeof(key)].has(key);\n                    }\n                },\n                'delete': {\n                    value: function (key) {\n                        if (this.has(key)) {\n                            size--;\n                            keys.splice(keys.indexOf(key), 1);\n                            return map[typeof(key)]['delete'](key);\n                        }\n                        return false;\n                    }\n                },\n                clear: {\n                    value: function () {\n                        keys.length = 0;\n                        for (var key in map) { map[key].clear(); }\n                        size = 0;\n                    }\n                },\n                forEach: {\n                    value: function (callback, thisArg) {\n                        for (var i = 0, n = keys.length; i < n; i++) {\n                            callback.call(thisArg, this.get(keys[i]), keys[i], this);\n                        }\n                    }\n                }\n            });\n            if (arguments.length > 0 && Array.isArray(arguments[0])) {\n                var iterable = arguments[0];\n                for (var i = 0, len = iterable.length; i < len; i++) {\n                    m.set(iterable[i][0], iterable[i][1]);\n                }\n            }\n            return m;\n        };\n    }\n\n    if (!hasForEach) {\n        var OldMap = global.Map;\n        global.Map = function Map() {\n            var map = new OldMap();\n            var size = 0;\n            var keys = [];\n            var m = Object.create(Map.prototype, {\n                size: {\n                    get : function () { return size; }\n                },\n                get: {\n                    value: function (key) {\n                        return map.get(key);\n                    }\n                },\n                set: {\n                    value: function (key, value) {\n                        if (!map.has(key)) {\n                            keys.push(key);\n                            size++;\n                        }\n                        map.set(key, value);\n                    }\n                },\n                has: {\n                    value: function (key) {\n                        return map.has(key);\n                    }\n                },\n                'delete': {\n                    value: function (key) {\n                        if (map.has(key)) {\n                            size--;\n                            keys.splice(keys.indexOf(key), 1);\n                            return map['delete'](key);\n                        }\n                        return false;\n                    }\n                },\n                clear: {\n                    value: function () {\n                        if ('clear' in map) {\n                            map.clear();\n                        }\n                        else {\n                            for (var i = 0, n = keys.length; i < n; i++) {\n                                map['delete'](keys[i]);\n                            }\n                        }\n                        keys.length = 0;\n                        size = 0;\n                    }\n                },\n                forEach: {\n                    value: function (callback, thisArg) {\n                        for (var i = 0, n = keys.length; i < n; i++) {\n                            callback.call(thisArg, this.get(keys[i]), keys[i], this);\n                        }\n                    }\n                }\n            });\n            if (arguments.length > 0 && Array.isArray(arguments[0])) {\n                var iterable = arguments[0];\n                for (var i = 0, len = iterable.length; i < len; i++) {\n                    m.set(iterable[i][0], iterable[i][1]);\n                }\n            }\n            return m;\n        };\n    }\n})();\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/common/Future.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/common/Future.js                                *\n *                                                        *\n * Hprose Future for Node.js.                             *\n *                                                        *\n * LastModified: Dec 5, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n(function() {\n    'use strict';\n\n    var TimeoutError = require('./TimeoutError');\n\n    var PENDING = 0;\n    var FULFILLED = 1;\n    var REJECTED = 2;\n\n    var hasPromise = 'Promise' in global;\n    var setTimeout = global.setTimeout;\n    var clearTimeout = global.clearTimeout;\n    var foreach = Array.prototype.forEach;\n    var slice = Array.prototype.slice;\n\n    function Future(computation) {\n        var self = this;\n        Object.defineProperties(this, {\n            _subscribers: { value: [] },\n            resolve: { value: this.resolve.bind(this) },\n            reject: { value: this.reject.bind(this) }\n        });\n        if (typeof computation === 'function') {\n            process.nextTick(function() {\n                try {\n                    self.resolve(computation());\n                }\n                catch(e) {\n                    self.reject(e);\n                }\n            });\n        }\n    }\n\n    function isFuture(obj) {\n        return obj instanceof Future;\n    }\n\n    function toFuture(obj) {\n        return isFuture(obj) ? obj : value(obj);\n    }\n\n    function isPromise(obj) {\n        return 'function' === typeof obj.then;\n    }\n\n    function delayed(duration, value) {\n        var computation = (typeof value === 'function') ?\n                          value :\n                          function() { return value; };\n        var future = new Future();\n        setTimeout(function() {\n            try {\n                future.resolve(computation());\n            }\n            catch(e) {\n                future.reject(e);\n            }\n        }, duration);\n        return future;\n    }\n\n    function error(e) {\n        var future = new Future();\n        future.reject(e);\n        return future;\n    }\n\n    function value(v) {\n        var future = new Future();\n        future.resolve(v);\n        return future;\n    }\n\n    function sync(computation) {\n        try {\n            var result = computation();\n            return value(result);\n        }\n        catch(e) {\n            return error(e);\n        }\n    }\n\n    function promise(executor) {\n        var future = new Future();\n        executor(future.resolve, future.reject);\n        return future;\n    }\n\n    function arraysize(array) {\n        var size = 0;\n        foreach.call(array, function() { ++size; });\n        return size;\n    }\n\n    function all(array) {\n        return toFuture(array).then(function(array) {\n            var n = array.length;\n            var count = arraysize(array);\n            var result = new Array(n);\n            if (count === 0) { return result; }\n            var future = new Future();\n            foreach.call(array, function(element, index) {\n                toFuture(element).then(function(value) {\n                    result[index] = value;\n                    if (--count === 0) {\n                        future.resolve(result);\n                    }\n                },\n                future.reject);\n            });\n            return future;\n        });\n    }\n\n    function join() {\n        return all(arguments);\n    }\n\n    function race(array) {\n        return toFuture(array).then(function(array) {\n            var future = new Future();\n            foreach.call(array, function(element) {\n                toFuture(element).fill(future);\n            });\n            return future;\n        });\n    }\n\n    function any(array) {\n        return toFuture(array).then(function(array) {\n            var n = array.length;\n            var count = arraysize(array);\n            if (count === 0) {\n                throw new RangeError('any(): array must not be empty');\n            }\n            var reasons = new Array(n);\n            var future = new Future();\n            foreach.call(array, function(element, index) {\n                toFuture(element).then(future.resolve, function(e) {\n                    reasons[index] = e;\n                    if (--count === 0) {\n                        future.reject(reasons);\n                    }\n                });\n            });\n            return future;\n        });\n    }\n\n    function settle(array) {\n        return toFuture(array).then(function(array) {\n            var n = array.length;\n            var count = arraysize(array);\n            var result = new Array(n);\n            if (count === 0) { return result; }\n            var future = new Future();\n            foreach.call(array, function(element, index) {\n                var f = toFuture(element);\n                f.complete(function() {\n                    result[index] = f.inspect();\n                    if (--count === 0) {\n                        future.resolve(result);\n                    }\n                });\n            });\n            return future;\n        });\n    }\n\n    function attempt(handler/*, arg1, arg2, ... */) {\n        var thisArg = (function() { return this; })();\n        var args = slice.call(arguments, 1);\n        return all(args).then(function(args) {\n            return handler.apply(thisArg, args);\n        });\n    }\n\n    function run(handler, thisArg/*, arg1, arg2, ... */) {\n        var args = slice.call(arguments, 2);\n        return all(args).then(function(args) {\n            return handler.apply(thisArg, args);\n        });\n    }\n\n    function isGenerator(obj) {\n        if (!obj) {\n            return false;\n        }\n        return 'function' == typeof obj.next && 'function' == typeof obj['throw'];\n    }\n\n    function isGeneratorFunction(obj) {\n        if (!obj) {\n            return false;\n        }\n        var constructor = obj.constructor;\n        if (!constructor) {\n            return false;\n        }\n        if ('GeneratorFunction' === constructor.name ||\n            'GeneratorFunction' === constructor.displayName) {\n            return true;\n        }\n        return isGenerator(constructor.prototype);\n    }\n\n    function getThunkCallback(future) {\n        return function(err, res) {\n            if (err instanceof Error) {\n                return future.reject(err);\n            }\n            if (arguments.length < 2) {\n                return future.resolve(err);\n            }\n            if (err === null || err === undefined) {\n                res = slice.call(arguments, 1);\n            }\n            else {\n                res = slice.call(arguments, 0);\n            }\n            if (res.length == 1) {\n                future.resolve(res[0]);\n            }\n            else {\n                future.resolve(res);\n            }\n        };\n    }\n\n    function thunkToPromise(fn) {\n        if (isGeneratorFunction(fn) || isGenerator(fn)) {\n            return co(fn);\n        }\n        var thisArg = (function() { return this; })();\n        var future = new Future();\n        fn.call(thisArg, getThunkCallback(future));\n        return future;\n    }\n\n    function thunkify(fn) {\n        return function() {\n            var args = slice.call(arguments, 0);\n            var thisArg = this;\n            var results = new Future();\n            args.push(function() {\n                thisArg = this;\n                results.resolve(arguments);\n            });\n            try {\n                fn.apply(this, args);\n            }\n            catch (err) {\n                results.resolve([err]);\n            }\n            return function(done) {\n                results.then(function(results) {\n                    done.apply(thisArg, results);\n                });\n            };\n        };\n    }\n\n    function promisify(fn) {\n        return function() {\n            var args = slice.call(arguments, 0);\n            var future = new Future();\n            args.push(getThunkCallback(future));\n            try {\n                fn.apply(this, args);\n            }\n            catch (err) {\n                future.reject(err);\n            }\n            return future;\n        };\n    }\n\n    function toPromise(obj) {\n        if (isGeneratorFunction(obj) || isGenerator(obj)) {\n            return co(obj);\n        }\n        return toFuture(obj);\n    }\n\n    function co(gen) {\n        var thisArg = (function() { return this; })();\n        if (typeof gen === 'function') {\n            var args = slice.call(arguments, 1);\n            gen = gen.apply(thisArg, args);\n        }\n\n        if (!gen || typeof gen.next !== 'function') {\n            return toFuture(gen);\n        }\n\n        var future = new Future();\n\n        function onFulfilled(res) {\n            try {\n                next(gen.next(res));\n            }\n            catch (e) {\n                future.reject(e);\n            }\n        }\n\n        function onRejected(err) {\n            try {\n                next(gen['throw'](err));\n            }\n            catch (e) {\n                future.reject(e);\n            }\n        }\n\n        function next(ret) {\n            if (ret.done) {\n                future.resolve(ret.value);\n            }\n            else {\n                (('function' == typeof ret.value) ?\n                thunkToPromise(ret.value) :\n                toPromise(ret.value)).then(onFulfilled, onRejected);\n            }\n        }\n\n        onFulfilled();\n\n        return future;\n    }\n\n    function wrap(handler, thisArg) {\n        return function() {\n            thisArg = thisArg || this;\n            return all(arguments).then(function(args) {\n                var result = handler.apply(thisArg, args);\n                if (isGeneratorFunction(result) || isGenerator(result)) {\n                    return co.call(thisArg, result);\n                }\n                return result;\n            });\n        };\n    }\n\n    co.wrap = wrap;\n\n    function forEach(array, callback, thisArg) {\n        thisArg = thisArg || (function() { return this; })();\n        return all(array).then(function(array) {\n            return array.forEach(callback, thisArg);\n        });\n    }\n\n    function every(array, callback, thisArg) {\n        thisArg = thisArg || (function() { return this; })();\n        return all(array).then(function(array) {\n            return array.every(callback, thisArg);\n        });\n    }\n\n    function some(array, callback, thisArg) {\n        thisArg = thisArg || (function() { return this; })();\n        return all(array).then(function(array) {\n            return array.some(callback, thisArg);\n        });\n    }\n\n    function filter(array, callback, thisArg) {\n        thisArg = thisArg || (function() { return this; })();\n        return all(array).then(function(array) {\n            return array.filter(callback, thisArg);\n        });\n    }\n\n    function map(array, callback, thisArg) {\n        thisArg = thisArg || (function() { return this; })();\n        return all(array).then(function(array) {\n            return array.map(callback, thisArg);\n        });\n    }\n\n    function reduce(array, callback, initialValue) {\n        if (arguments.length > 2) {\n            return all(array).then(function(array) {\n                return toFuture(initialValue).then(function(value) {\n                    return array.reduce(callback, value);\n                });\n            });\n        }\n        return all(array).then(function(array) {\n            return array.reduce(callback);\n        });\n    }\n\n    function reduceRight(array, callback, initialValue) {\n        if (arguments.length > 2) {\n            return all(array).then(function(array) {\n                return toFuture(initialValue).then(function(value) {\n                    return array.reduceRight(callback, value);\n                });\n            });\n        }\n        return all(array).then(function(array) {\n            return array.reduceRight(callback);\n        });\n    }\n\n    function indexOf(array, searchElement, fromIndex) {\n        return all(array).then(function(array) {\n            return toFuture(searchElement).then(function(searchElement) {\n                return array.indexOf(searchElement, fromIndex);\n            });\n        });\n    }\n\n    function lastIndexOf(array, searchElement, fromIndex) {\n        return all(array).then(function(array) {\n            return toFuture(searchElement).then(function(searchElement) {\n                if (fromIndex === undefined) {\n                    fromIndex = array.length - 1;\n                }\n                return array.lastIndexOf(searchElement, fromIndex);\n            });\n        });\n    }\n\n    function includes(array, searchElement, fromIndex) {\n        return all(array).then(function(array) {\n            return toFuture(searchElement).then(function(searchElement) {\n                return array.includes(searchElement, fromIndex);\n            });\n        });\n    }\n\n    function find(array, predicate, thisArg) {\n        thisArg = thisArg || (function() { return this; })();\n        return all(array).then(function(array) {\n            return array.find(predicate, thisArg);\n        });\n    }\n\n    function findIndex(array, predicate, thisArg) {\n        thisArg = thisArg || (function() { return this; })();\n        return all(array).then(function(array) {\n            return array.findIndex(predicate, thisArg);\n        });\n    }\n\n    Object.defineProperties(Future, {\n        // port from Dart\n        delayed: { value: delayed },\n        error: { value: error },\n        sync: { value: sync },\n        value: { value: value },\n        // Promise compatible\n        all: { value: all },\n        race: { value: race },\n        resolve: { value: value },\n        reject: { value: error },\n        // extended methods\n        promise: { value: promise },\n        isFuture: { value: isFuture },\n        toFuture: { value: toFuture },\n        isPromise: { value: isPromise },\n        toPromise: { value: toPromise },\n        join: { value: join },\n        any: { value: any },\n        settle: { value: settle },\n        attempt: { value: attempt },\n        run: { value: run },\n        thunkify: { value: thunkify },\n        promisify: { value: promisify },\n        co: { value: co },\n        wrap: { value: wrap },\n        // for array\n        forEach: { value: forEach },\n        every: { value: every },\n        some: { value: some },\n        filter: { value: filter },\n        map: { value: map },\n        reduce: { value: reduce },\n        reduceRight: { value: reduceRight },\n        indexOf: { value: indexOf },\n        lastIndexOf: { value: lastIndexOf },\n        includes: { value: includes },\n        find: { value: find },\n        findIndex: { value: findIndex }\n    });\n\n    function _call(callback, next, x) {\n        process.nextTick(function() {\n            try {\n                var r = callback(x);\n                next.resolve(r);\n            }\n            catch(e) {\n                next.reject(e);\n            }\n        });\n    }\n\n    function _resolve(onfulfill, next, x) {\n        if (onfulfill) {\n            _call(onfulfill, next, x);\n        }\n        else {\n            next.resolve(x);\n        }\n    }\n\n    function _reject(onreject, next, e) {\n        if (onreject) {\n            _call(onreject, next, e);\n        }\n        else {\n            next.reject(e);\n        }\n    }\n\n    Object.defineProperties(Future.prototype, {\n        _value: { writable: true },\n        _reason: { writable: true },\n        _state: { value: PENDING, writable: true },\n        resolve: { value: function(value) {\n            if (value === this) {\n                this.reject(new TypeError('Self resolution'));\n                return;\n            }\n            if (isFuture(value)) {\n                value.fill(this);\n                return;\n            }\n            if ((value !== null) &&\n                (typeof value === 'object') ||\n                (typeof value === 'function')) {\n                var then;\n                try {\n                    then = value.then;\n                }\n                catch (e) {\n                    this.reject(e);\n                    return;\n                }\n                if (typeof then === 'function') {\n                    var notrun = true;\n                    try {\n                        var self = this;\n                        then.call(value, function(y) {\n                            if (notrun) {\n                                notrun = false;\n                                self.resolve(y);\n                            }\n                        }, function(r) {\n                            if (notrun) {\n                                notrun = false;\n                                self.reject(r);\n                            }\n                        });\n                        return;\n                    }\n                    catch (e) {\n                        if (notrun) {\n                            notrun = false;\n                            this.reject(e);\n                        }\n                    }\n                    return;\n                }\n            }\n            if (this._state === PENDING) {\n                this._state = FULFILLED;\n                this._value = value;\n                var subscribers = this._subscribers;\n                while (subscribers.length > 0) {\n                    var subscriber = subscribers.shift();\n                    _resolve(subscriber.onfulfill, subscriber.next, value);\n                }\n            }\n        } },\n        reject: { value: function(reason) {\n            if (this._state === PENDING) {\n                this._state = REJECTED;\n                this._reason = reason;\n                var subscribers = this._subscribers;\n                while (subscribers.length > 0) {\n                    var subscriber = subscribers.shift();\n                    _reject(subscriber.onreject, subscriber.next, reason);\n                }\n            }\n        } },\n        then: { value: function(onfulfill, onreject) {\n            if (typeof onfulfill !== 'function') { onfulfill = null; }\n            if (typeof onreject !== 'function') { onreject = null; }\n            var next = new Future();\n            if (this._state === FULFILLED) {\n                _resolve(onfulfill, next, this._value);\n            }\n            else if (this._state === REJECTED) {\n                _reject(onreject, next, this._reason);\n            }\n            else {\n                this._subscribers.push({\n                    onfulfill: onfulfill,\n                    onreject: onreject,\n                    next: next\n                });\n            }\n            return next;\n        } },\n        done: { value: function(onfulfill, onreject) {\n            this.then(onfulfill, onreject).then(null, function(error) {\n                process.nextTick(function() { throw error; });\n            });\n        } },\n        inspect: { value: function() {\n            switch (this._state) {\n                case PENDING: return { state: 'pending' };\n                case FULFILLED: return { state: 'fulfilled', value: this._value };\n                case REJECTED: return { state: 'rejected', reason: this._reason };\n            }\n        } },\n        catchError: { value: function(onreject, test) {\n            if (typeof test === 'function') {\n                var self = this;\n                return this['catch'](function(e) {\n                    if (test(e)) {\n                        return self['catch'](onreject);\n                    }\n                    else {\n                        throw e;\n                    }\n                });\n            }\n            return this['catch'](onreject);\n        } },\n        'catch': { value: function(onreject) {\n            return this.then(null, onreject);\n        } },\n        fail: { value: function(onreject) {\n            this.done(null, onreject);\n        } },\n        whenComplete: { value: function(action) {\n            return this.then(\n                function(v) { action(); return v; },\n                function(e) { action(); throw e; }\n            );\n        } },\n        complete: { value: function(oncomplete) {\n            oncomplete = oncomplete || function(v) { return v; };\n            return this.then(oncomplete, oncomplete);\n        } },\n        always: { value: function(oncomplete) {\n           this.done(oncomplete, oncomplete);\n        } },\n        fill: { value: function(future) {\n           this.then(future.resolve, future.reject);\n        } },\n        timeout: { value: function(duration, reason) {\n            var future = new Future();\n            var timeoutId = setTimeout(function() {\n                future.reject(reason || new TimeoutError('timeout'));\n            }, duration);\n            this.whenComplete(function() { clearTimeout(timeoutId); })\n                .fill(future);\n            return future;\n        } },\n        delay: { value: function(duration) {\n            var future = new Future();\n            this.then(function(result) {\n                setTimeout(function() {\n                    future.resolve(result);\n                }, duration);\n            },\n            future.reject);\n            return future;\n        } },\n        tap: { value: function(onfulfilledSideEffect, thisArg) {\n            return this.then(function(result) {\n                onfulfilledSideEffect.call(thisArg, result);\n                return result;\n            });\n        } },\n        spread: { value: function(onfulfilledArray, thisArg) {\n            return this.then(function(array) {\n                return onfulfilledArray.apply(thisArg, array);\n            });\n        } },\n        get: { value: function(key) {\n            return this.then(function(result) {\n                return result[key];\n            });\n        } },\n        set: { value: function(key, value) {\n            return this.then(function(result) {\n                result[key] = value;\n                return result;\n            });\n        } },\n        apply: { value: function(method, args) {\n            args = args || [];\n            return this.then(function(result) {\n                return all(args).then(function(args) {\n                    return result[method].apply(result, args);\n                });\n            });\n        } },\n        call: { value: function(method) {\n            var args = slice.call(arguments, 1);\n            return this.then(function(result) {\n                return all(args).then(function(args) {\n                    return result[method].apply(result, args);\n                });\n            });\n        } },\n        bind: { value: function(method) {\n            var bindargs = slice.call(arguments);\n            if (Array.isArray(method)) {\n                for (var i = 0, n = method.length; i < n; ++i) {\n                    bindargs[0] = method[i];\n                    this.bind.apply(this, bindargs);\n                }\n                return;\n            }\n            bindargs.shift();\n            var self = this;\n            Object.defineProperty(this, method, { value: function() {\n                var args = slice.call(arguments);\n                return self.then(function(result) {\n                    return all(bindargs.concat(args)).then(function(args) {\n                        return result[method].apply(result, args);\n                    });\n                });\n            } });\n            return this;\n        } },\n        forEach: { value: function(callback, thisArg) {\n            return forEach(this, callback, thisArg);\n        } },\n        every: { value: function(callback, thisArg) {\n            return every(this, callback, thisArg);\n        } },\n        some: { value: function(callback, thisArg) {\n            return some(this, callback, thisArg);\n        } },\n        filter: { value: function(callback, thisArg) {\n            return filter(this, callback, thisArg);\n        } },\n        map: { value: function(callback, thisArg) {\n            return map(this, callback, thisArg);\n        } },\n        reduce: { value: function(callback, initialValue) {\n            if (arguments.length > 1) {\n                return reduce(this, callback, initialValue);\n            }\n            return reduce(this, callback);\n        } },\n        reduceRight: { value: function(callback, initialValue) {\n            if (arguments.length > 1) {\n                return reduceRight(this, callback, initialValue);\n            }\n            return reduceRight(this, callback);\n        } },\n        indexOf: { value: function(searchElement, fromIndex) {\n            return indexOf(this, searchElement, fromIndex);\n        } },\n        lastIndexOf: { value: function(searchElement, fromIndex) {\n            return lastIndexOf(this, searchElement, fromIndex);\n        } },\n        includes: { value: function(searchElement, fromIndex) {\n            return includes(this, searchElement, fromIndex);\n        } },\n        find: { value: function(predicate, thisArg) {\n            return find(this, predicate, thisArg);\n        } },\n        findIndex: { value: function(predicate, thisArg) {\n            return findIndex(this, predicate, thisArg);\n        } }\n    });\n\n    global.hprose.Future = Future;\n\n    global.hprose.thunkify = thunkify;\n    global.hprose.promisify = promisify;\n    global.hprose.co = co;\n    global.hprose.co.wrap = global.hprose.wrap = wrap;\n\n    function Completer() {\n        var future = new Future();\n        Object.defineProperties(this, {\n            future: { value: future },\n            complete: { value: future.resolve },\n            completeError: { value: future.reject },\n            isCompleted: { get: function() {\n                return ( future._state !== PENDING );\n            } }\n        });\n    }\n\n    global.hprose.Completer = Completer;\n\n    global.hprose.resolved = value;\n\n    global.hprose.rejected = error;\n\n    global.hprose.deferred = function() {\n        var self = new Future();\n        return Object.create(null, {\n            promise: { value: self },\n            resolve: { value: self.resolve },\n            reject: { value: self.reject }\n        });\n    };\n\n    if (hasPromise) { return; }\n\n    global.Promise = function(executor) {\n        Future.call(this);\n        executor(this.resolve, this.reject);\n    };\n\n    global.Promise.prototype = Object.create(Future.prototype);\n    global.Promise.prototype.constructor = Future;\n\n    Object.defineProperties(global.Promise, {\n        all: { value: all },\n        race: { value: race },\n        resolve: { value: value },\n        reject: { value: error }\n    });\n})();\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/common/TimeoutError.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * TimeoutError.js                                        *\n *                                                        *\n * TimeoutError for Node.js.                              *\n *                                                        *\n * LastModified: Jul 17, 2015                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\nfunction TimeoutError(message) {\n    Error.call(this);\n    this.message = message;\n    this.name = TimeoutError.name;\n    if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(this, TimeoutError);\n    }\n}\n\nTimeoutError.prototype = Object.create(Error.prototype);\nTimeoutError.prototype.constructor = TimeoutError;\n\nmodule.exports = TimeoutError;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/common/ResultMode.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/common/ResultMode.js                            *\n *                                                        *\n * Hprose ResultMode for Node.js.                         *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nglobal.hprose.ResultMode = {\n    Normal: 0,\n    Serialized: 1,\n    Raw: 2,\n    RawWithEndTag: 3\n};\nglobal.hprose.Normal        = global.hprose.ResultMode.Normal;\nglobal.hprose.Serialized    = global.hprose.ResultMode.Serialized;\nglobal.hprose.Raw           = global.hprose.ResultMode.Raw;\nglobal.hprose.RawWithEndTag = global.hprose.ResultMode.RawWithEndTag;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/io/BytesIO.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/io/BytesIO.js                                   *\n *                                                        *\n * Hprose BytesIO for Node.js.                            *\n *                                                        *\n * LastModified: Oct 23, 2016                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar toBinaryString = global.hprose.toBinaryString;\n\nvar _EMPTY_BYTES = new Uint8Array(0);\nvar _INIT_SIZE = 1024;\n\nfunction writeInt32BE(bytes, p, i) {\n    bytes[p++] = i >>> 24 & 0xFF;\n    bytes[p++] = i >>> 16 & 0xFF;\n    bytes[p++] = i >>> 8  & 0xFF;\n    bytes[p++] = i        & 0xFF;\n    return p;\n}\n\nfunction writeInt32LE(bytes, p, i) {\n    bytes[p++] = i        & 0xFF;\n    bytes[p++] = i >>> 8  & 0xFF;\n    bytes[p++] = i >>> 16 & 0xFF;\n    bytes[p++] = i >>> 24 & 0xFF;\n    return p;\n}\n\nfunction writeString(bytes, p, str) {\n    var n = str.length;\n    for (var i = 0; i < n; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit < 0x80) {\n            bytes[p++] = codeUnit;\n        }\n        else if (codeUnit < 0x800) {\n            bytes[p++] = 0xC0 | (codeUnit >> 6);\n            bytes[p++] = 0x80 | (codeUnit & 0x3F);\n        }\n        else if (codeUnit < 0xD800 || codeUnit > 0xDFFF) {\n            bytes[p++] = 0xE0 | (codeUnit >> 12);\n            bytes[p++] = 0x80 | ((codeUnit >> 6) & 0x3F);\n            bytes[p++] = 0x80 | (codeUnit & 0x3F);\n        }\n        else {\n            if (i + 1 < n) {\n                var nextCodeUnit = str.charCodeAt(i + 1);\n                if (codeUnit < 0xDC00 && 0xDC00 <= nextCodeUnit && nextCodeUnit <= 0xDFFF) {\n                    var rune = (((codeUnit & 0x03FF) << 10) | (nextCodeUnit & 0x03FF)) + 0x010000;\n                    bytes[p++] = 0xF0 | (rune >> 18);\n                    bytes[p++] = 0x80 | ((rune >> 12) & 0x3F);\n                    bytes[p++] = 0x80 | ((rune >> 6) & 0x3F);\n                    bytes[p++] = 0x80 | (rune & 0x3F);\n                    ++i;\n                    continue;\n                }\n            }\n            throw new Error('Malformed string');\n        }\n    }\n    return p;\n}\n\nfunction readShortString(bytes, n) {\n    var charCodes = new Uint16Array(n);\n    var i = 0, off = 0;\n    for (var len = bytes.length; i < n && off < len; i++) {\n        var unit = bytes[off++];\n        switch (unit >> 4) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n            charCodes[i] = unit;\n            break;\n        case 12:\n        case 13:\n            if (off < len) {\n                charCodes[i] = ((unit & 0x1F) << 6) |\n                                (bytes[off++] & 0x3F);\n                break;\n            }\n            throw new Error('Unfinished UTF-8 octet sequence');\n        case 14:\n            if (off + 1 < len) {\n                charCodes[i] = ((unit & 0x0F) << 12) |\n                               ((bytes[off++] & 0x3F) << 6) |\n                               (bytes[off++] & 0x3F);\n                break;\n            }\n            throw new Error('Unfinished UTF-8 octet sequence');\n        case 15:\n            if (off + 2 < len) {\n                var rune = (((unit & 0x07) << 18) |\n                            ((bytes[off++] & 0x3F) << 12) |\n                            ((bytes[off++] & 0x3F) << 6) |\n                            (bytes[off++] & 0x3F)) - 0x10000;\n                if (0 <= rune && rune <= 0xFFFFF) {\n                    charCodes[i++] = (((rune >> 10) & 0x03FF) | 0xD800);\n                    charCodes[i] = ((rune & 0x03FF) | 0xDC00);\n                    break;\n                }\n                throw new Error('Character outside valid Unicode range: 0x' + rune.toString(16));\n            }\n            throw new Error('Unfinished UTF-8 octet sequence');\n        default:\n            throw new Error('Bad UTF-8 encoding 0x' + unit.toString(16));\n        }\n    }\n    if (i < n) {\n        charCodes = charCodes.subarray(0, i);\n    }\n    return [String.fromCharCode.apply(String, charCodes), off];\n}\n\nfunction readLongString(bytes, n) {\n    var buf = [];\n    var charCodes = new Uint16Array(0x8000);\n    var i = 0, off = 0;\n    for (var len = bytes.length; i < n && off < len; i++) {\n        var unit = bytes[off++];\n        switch (unit >> 4) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n            charCodes[i] = unit;\n            break;\n        case 12:\n        case 13:\n            if (off < len) {\n                charCodes[i] = ((unit & 0x1F) << 6) |\n                                (bytes[off++] & 0x3F);\n                break;\n            }\n            throw new Error('Unfinished UTF-8 octet sequence');\n        case 14:\n            if (off + 1 < len) {\n                charCodes[i] = ((unit & 0x0F) << 12) |\n                               ((bytes[off++] & 0x3F) << 6) |\n                               (bytes[off++] & 0x3F);\n                break;\n            }\n            throw new Error('Unfinished UTF-8 octet sequence');\n        case 15:\n            if (off + 2 < len) {\n                var rune = (((unit & 0x07) << 18) |\n                            ((bytes[off++] & 0x3F) << 12) |\n                            ((bytes[off++] & 0x3F) << 6) |\n                            (bytes[off++] & 0x3F)) - 0x10000;\n                if (0 <= rune && rune <= 0xFFFFF) {\n                    charCodes[i++] = (((rune >> 10) & 0x03FF) | 0xD800);\n                    charCodes[i] = ((rune & 0x03FF) | 0xDC00);\n                    break;\n                }\n                throw new Error('Character outside valid Unicode range: 0x' + rune.toString(16));\n            }\n            throw new Error('Unfinished UTF-8 octet sequence');\n        default:\n            throw new Error('Bad UTF-8 encoding 0x' + unit.toString(16));\n        }\n        if (i >= 0x7FFF - 1) {\n            var size = i + 1;\n            buf.push(String.fromCharCode.apply(String, charCodes.subarray(0, size)));\n            n -= size;\n            i = -1;\n        }\n    }\n    if (i > 0) {\n        buf.push(String.fromCharCode.apply(String, charCodes.subarray(0, i)));\n    }\n    return [buf.join(''), off];\n}\n\nfunction readString(bytes, n) {\n    if (n === undefined || n === null || (n < 0)) { n = bytes.length; }\n    if (n === 0) { return ['', 0]; }\n    return ((n < 0xFFFF) ?\n            readShortString(bytes, n) :\n            readLongString(bytes, n));\n}\n\nfunction readStringAsBytes(bytes, n) {\n    if (n === undefined) { n = bytes.length; }\n    if (n === 0) { return [_EMPTY_BYTES, 0]; }\n    var i = 0, off = 0;\n    for (var len = bytes.length; i < n && off < len; i++) {\n        var unit = bytes[off++];\n        switch (unit >> 4) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n            break;\n        case 12:\n        case 13:\n            if (off < len) {\n                off++;\n                break;\n            }\n            throw new Error('Unfinished UTF-8 octet sequence');\n        case 14:\n            if (off + 1 < len) {\n                off += 2;\n                break;\n            }\n            throw new Error('Unfinished UTF-8 octet sequence');\n        case 15:\n            if (off + 2 < len) {\n                var rune = (((unit & 0x07) << 18) |\n                            ((bytes[off++] & 0x3F) << 12) |\n                            ((bytes[off++] & 0x3F) << 6) |\n                            (bytes[off++] & 0x3F)) - 0x10000;\n                if (0 <= rune && rune <= 0xFFFFF) {\n                    i++;\n                    break;\n                }\n                throw new Error('Character outside valid Unicode range: 0x' + rune.toString(16));\n            }\n            throw new Error('Unfinished UTF-8 octet sequence');\n        default:\n            throw new Error('Bad UTF-8 encoding 0x' + unit.toString(16));\n        }\n    }\n    return [bytes.subarray(0, off), off];\n}\n\nfunction pow2roundup(x) {\n    --x;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    return x + 1;\n}\n\nfunction BytesIO() {\n    var a = arguments;\n    switch (a.length) {\n    case 1:\n        switch (a[0].constructor) {\n        case Uint8Array:\n            this._bytes = a[0];\n            this._length = a[0].length;\n            break;\n        case BytesIO:\n            this._bytes = a[0].toBytes();\n            this._length = a[0].length;\n            break;\n        case String:\n            this.writeString(a[0]);\n            break;\n        case Number:\n            this._bytes = new Uint8Array(a[0]);\n            break;\n        default:\n            this._bytes = new Uint8Array(a[0]);\n            this._length = this._bytes.length;\n            break;\n        }\n        break;\n    case 2:\n        this._bytes = new Uint8Array(a[0], a[1]);\n        this._length = a[1];\n        break;\n    case 3:\n        this._bytes = new Uint8Array(a[0], a[1], a[2]);\n        this._length = a[2];\n        break;\n    }\n    this.mark();\n}\n\nObject.defineProperties(BytesIO.prototype, {\n    _bytes: { value: null, writable: true },\n    _length: { value: 0, writable: true },\n    _wmark: { value: 0, writable: true },\n    _off: { value: 0, writable: true },\n    _rmark: { value: 0, writable: true },\n    _grow: { value: function(n) {\n        var bytes = this._bytes;\n        var required = this._length + n;\n        var size = pow2roundup(required);\n        if (bytes) {\n            size *= 2;\n            if (size > bytes.length) {\n                var buf = new Uint8Array(size);\n                buf.set(bytes);\n                this._bytes = buf;\n            }\n        }\n        else {\n            size = Math.max(size, _INIT_SIZE);\n            this._bytes = new Uint8Array(size);\n        }\n    } },\n    length: { get: function() { return this._length; } },\n    capacity: { get: function() {\n        return this._bytes ? this._bytes.length : 0;\n    } },\n    position: { get: function() { return this._off; } },\n    // returns a view of the the internal buffer.\n    bytes: { get : function() {\n        return (this._bytes === null) ?\n                _EMPTY_BYTES :\n                this._bytes.subarray(0, this._length);\n    } },\n    mark: { value: function() {\n        this._wmark = this._length;\n        this._rmark = this._off;\n    } },\n    reset: { value: function() {\n        this._length = this._wmark;\n        this._off = this._rmark;\n    } },\n    clear: { value: function() {\n        this._bytes = null;\n        this._length = 0;\n        this._wmark = 0;\n        this._off = 0;\n        this._rmark = 0;\n    } },\n    writeByte: { value: function(b) {\n        this._grow(1);\n        this._bytes[this._length++] = b;\n    } },\n    writeInt32BE: { value: function(i) {\n        if ((i === (i | 0)) && (i <= 2147483647)) {\n            this._grow(4);\n            this._length = writeInt32BE(this._bytes, this._length, i);\n            return;\n        }\n        throw new TypeError('value is out of bounds');\n    } },\n    writeUInt32BE: { value: function(i) {\n        if (((i & 0x7FFFFFFF) + 0x80000000 === i) && (i >= 0)) {\n            this._grow(4);\n            this._length = writeInt32BE(this._bytes, this._length, i | 0);\n            return;\n        }\n        throw new TypeError('value is out of bounds');\n    } },\n    writeInt32LE: { value: function(i) {\n        if ((i === (i | 0)) && (i <= 2147483647)) {\n            this._grow(4);\n            this._length = writeInt32LE(this._bytes, this._length, i);\n            return;\n        }\n        throw new TypeError('value is out of bounds');\n    } },\n    writeUInt32LE: { value: function(i) {\n        if (((i & 0x7FFFFFFF) + 0x80000000 === i) && (i >= 0)) {\n            this._grow(4);\n            this._length = writeInt32LE(this._bytes, this._length, i | 0);\n            return;\n        }\n        throw new TypeError('value is out of bounds');\n    } },\n    write: { value: function(data) {\n        var n = data.byteLength || data.length;\n        if (n === 0) { return; }\n        this._grow(n);\n        var bytes = this._bytes;\n        var length = this._length;\n        switch (data.constructor) {\n        case ArrayBuffer:\n            bytes.set(new Uint8Array(data), length);\n            break;\n        case Uint8Array:\n            bytes.set(data, length);\n            break;\n        case BytesIO:\n            bytes.set(data.bytes, length);\n            break;\n        default:\n            for (var i = 0; i < n; i++) {\n                bytes[length + i] = data[i];\n            }\n            break;\n        }\n        this._length += n;\n    } },\n    writeAsciiString: { value: function(str) {\n        var n = str.length;\n        if (n === 0) { return; }\n        this._grow(n);\n        var bytes = this._bytes;\n        var l = this._length;\n        for (var i = 0; i < n; ++i, ++l) {\n            bytes[l] = str.charCodeAt(i);\n        }\n        this._length = l;\n    } },\n    writeString: { value: function(str) {\n        var n = str.length;\n        if (n === 0) { return; }\n        // A single code unit uses at most 3 bytes.\n        // Two code units at most 4.\n        this._grow(n * 3);\n        this._length = writeString(this._bytes, this._length, str);\n    } },\n    readByte: { value: function() {\n        if (this._off < this._length) {\n            return this._bytes[this._off++];\n        }\n        return -1;\n    } },\n    readInt32BE: { value: function() {\n        var bytes = this._bytes;\n        var off = this._off;\n        if (off + 3 < this._length) {\n            var result = bytes[off++] << 24 |\n                         bytes[off++] << 16 |\n                         bytes[off++] << 8  |\n                         bytes[off++];\n            this._off = off;\n            return result;\n        }\n        throw new Error('EOF');\n    } },\n    readUInt32BE: { value: function() {\n        var value = this.readInt32BE();\n        if (value < 0) {\n            return (value & 0x7FFFFFFF) + 0x80000000;\n        }\n        return value;\n    } },\n    readInt32LE: { value: function() {\n        var bytes = this._bytes;\n        var off = this._off;\n        if (off + 3 < this._length) {\n            var result = bytes[off++]       |\n                         bytes[off++] << 8  |\n                         bytes[off++] << 16 |\n                         bytes[off++] << 24;\n            this._off = off;\n            return result;\n        }\n        throw new Error('EOF');\n    } },\n    readUInt32LE: { value: function() {\n        var value = this.readInt32LE();\n        if (value < 0) {\n            return (value & 0x7FFFFFFF) + 0x80000000;\n        }\n        return value;\n    } },\n    read: { value: function(n) {\n        if (this._off + n > this._length) {\n            n = this._length - this._off;\n        }\n        if (n === 0) { return _EMPTY_BYTES; }\n        return this._bytes.subarray(this._off, this._off += n);\n    } },\n    skip: { value: function(n) {\n        if (this._off + n > this._length) {\n            n = this._length - this._off;\n            this._off = this._length;\n        }\n        else {\n            this._off += n;\n        }\n        return n;\n    } },\n    // the result is an Uint8Array, and includes tag.\n    readBytes: { value: function(tag) {\n        var pos = Array.indexOf(this._bytes, tag, this._off);\n        var buf;\n        if (pos === -1) {\n            buf = this._bytes.subarray(this._off, this._length);\n            this._off = this._length;\n        }\n        else {\n            buf = this._bytes.subarray(this._off, pos + 1);\n            this._off = pos + 1;\n        }\n        return buf;\n    } },\n    // the result is a String, and doesn't include tag.\n    // but the position is the same as readBytes\n    readUntil: { value: function(tag) {\n        var pos = Array.indexOf(this._bytes, tag, this._off);\n        var str = '';\n        if (pos === this._off) {\n            this._off++;\n        }\n        else if (pos === -1) {\n            str = readString(this._bytes.subarray(this._off, this._length))[0];\n            this._off = this._length;\n        }\n        else {\n            str = readString(this._bytes.subarray(this._off, pos))[0];\n            this._off = pos + 1;\n        }\n        return str;\n    } },\n    readAsciiString: { value: function(n) {\n        if (this._off + n > this._length) {\n            n = this._length - this._off;\n        }\n        if (n === 0) { return ''; }\n        return toBinaryString(this._bytes.subarray(this._off, this._off += n));\n    } },\n    // n is the UTF16 length\n    readStringAsBytes: { value: function(n) {\n        var r = readStringAsBytes(this._bytes.subarray(this._off, this._length), n);\n        this._off += r[1];\n        return r[0];\n    } },\n    // n is the UTF16 length\n    readString: { value: function(n) {\n        var r = readString(this._bytes.subarray(this._off, this._length), n);\n        this._off += r[1];\n        return r[0];\n    } },\n    // returns a view of the the internal buffer and clears `this`.\n    takeBytes: { value: function() {\n        var buffer = this.bytes;\n        this.clear();\n        return buffer;\n    } },\n    // returns a copy of the current contents and leaves `this` intact.\n    toBytes: { value: function() {\n        return new Uint8Array(this.bytes);\n    } },\n    // returns a Buffer copy of the current contents and leaves `this` intact.\n    toBuffer: { value: function() {\n        var bytes = this._bytes;\n        var length = this._length;\n        var buffer = new Buffer(length);\n        for (var i = 0; i < length; ++i) {\n            buffer[i] = bytes[i];\n        }\n        return buffer;\n    } },\n    toString: { value: function() {\n        return readString(this.bytes, this._length)[0];\n    } },\n    clone: { value: function() {\n        return new BytesIO(this.toBytes());\n    } },\n    trunc: { value: function() {\n        this._bytes = this._bytes.subarray(this._off, this._length);\n        this._length = this._bytes.length;\n        this._off = 0;\n        this._wmark = 0;\n        this._rmark = 0;\n    } }\n});\n\nfunction toString(data) {\n    /* jshint -W086 */\n    if (data.length === 0) { return ''; }\n    switch(data.constructor) {\n    case String: return data;\n    case Buffer: return data.toString();\n    case BytesIO: data = data.bytes;\n    case ArrayBuffer: data = new Uint8Array(data);\n    case Uint8Array: return readString(data, data.length)[0];\n    default: return String.fromCharCode.apply(String, data);\n    }\n}\n\nfunction toBuffer(data) {\n    /* jshint -W086 */\n    switch(data.constructor) {\n    case Buffer: return data;\n    case ArrayBuffer: data = new Uint8Array(data);\n    case Uint8Array: data = new BytesIO(data);\n    case BytesIO: return data.toBuffer();\n    default: return new Buffer(data);\n    }\n}\n\nObject.defineProperties(BytesIO, {\n    toString: { value: toString },\n    toBuffer: { value: toBuffer }\n});\n\nglobal.hprose.BytesIO = BytesIO;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/io/ClassManager.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/io/ClassManager.js                              *\n *                                                        *\n * hprose ClassManager for Node.js.                       *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar WeakMap = global.WeakMap;\n\nvar classCache = Object.create(null);\nvar aliasCache = new WeakMap();\n\nfunction register(cls, alias) {\n    aliasCache.set(cls, alias);\n    classCache[alias] = cls;\n}\n\nfunction getClassAlias(cls) {\n    return aliasCache.get(cls);\n}\n\nfunction getClass(alias) {\n    return classCache[alias];\n}\n\nglobal.hprose.ClassManager = Object.create(null, {\n    register: { value: register },\n    getClassAlias: { value: getClassAlias },\n    getClass: { value: getClass }\n});\n\nglobal.hprose.register = register;\n\nregister(Object, 'Object');\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/io/Tags.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/io/Tags.js                                      *\n *                                                        *\n * Hprose Tags for Node.js.                               *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nglobal.hprose.Tags = {\n    /* Serialize Tags */\n    TagInteger     : 0x69, //  'i'\n    TagLong        : 0x6C, //  'l'\n    TagDouble      : 0x64, //  'd'\n    TagNull        : 0x6E, //  'n'\n    TagEmpty       : 0x65, //  'e'\n    TagTrue        : 0x74, //  't'\n    TagFalse       : 0x66, //  'f'\n    TagNaN         : 0x4E, //  'N'\n    TagInfinity    : 0x49, //  'I'\n    TagDate        : 0x44, //  'D'\n    TagTime        : 0x54, //  'T'\n    TagUTC         : 0x5A, //  'Z'\n    TagBytes       : 0x62, //  'b'\n    TagUTF8Char    : 0x75, //  'u'\n    TagString      : 0x73, //  's'\n    TagGuid        : 0x67, //  'g'\n    TagList        : 0x61, //  'a'\n    TagMap         : 0x6d, //  'm'\n    TagClass       : 0x63, //  'c'\n    TagObject      : 0x6F, //  'o'\n    TagRef         : 0x72, //  'r'\n    /* Serialize Marks */\n    TagPos         : 0x2B, //  '+'\n    TagNeg         : 0x2D, //  '-'\n    TagSemicolon   : 0x3B, //  ','\n    TagOpenbrace   : 0x7B, //  '{'\n    TagClosebrace  : 0x7D, //  '}'\n    TagQuote       : 0x22, //  '\"'\n    TagPoint       : 0x2E, //  '.'\n    /* Protocol Tags */\n    TagFunctions   : 0x46, //  'F'\n    TagCall        : 0x43, //  'C'\n    TagResult      : 0x52, //  'R'\n    TagArgument    : 0x41, //  'A'\n    TagError       : 0x45, //  'E'\n    TagEnd         : 0x7A  //  'z'\n};\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/io/Writer.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/io/Writer.js                                    *\n *                                                        *\n * Hprose Writer for Node.js.                             *\n *                                                        *\n * LastModified: Feb 13, 2017                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar Map = global.Map;\nvar BytesIO = global.hprose.BytesIO;\nvar Tags = global.hprose.Tags;\nvar ClassManager = global.hprose.ClassManager;\n\nfunction getClassName(obj) {\n    var cls = obj.constructor;\n    if (!cls) {\n        return 'Object';\n    }\n    var classname = ClassManager.getClassAlias(cls);\n    if (classname) { return classname; }\n    if (cls.name) {\n        classname = cls.name;\n    }\n    else {\n        var ctor = cls.toString();\n        classname = ctor.substr(0, ctor.indexOf('(')).replace(/(^\\s*function\\s*)|(\\s*$)/ig, '');\n        if (classname === '' || classname === 'Object') {\n            return (typeof(obj.getClassName) === 'function') ? obj.getClassName() : 'Object';\n        }\n    }\n    if (classname !== 'Object') {\n        ClassManager.register(cls, classname);\n    }\n    return classname;\n}\n\nvar fakeWriterRefer = Object.create(null, {\n    set: { value: function () {} },\n    write: { value: function () { return false; } },\n    reset: { value: function () {} }\n});\n\nfunction RealWriterRefer(stream) {\n    Object.defineProperties(this, {\n        _stream: { value: stream },\n        _ref: { value: new Map(), writable: true }\n    });\n}\n\nObject.defineProperties(RealWriterRefer.prototype, {\n    _refcount: { value: 0, writable: true },\n    set: { value: function (val) {\n        this._ref.set(val, this._refcount++);\n    } },\n    write: { value: function (val) {\n        var index = this._ref.get(val);\n        if (index !== undefined) {\n            this._stream.writeByte(Tags.TagRef);\n            this._stream.writeString('' + index);\n            this._stream.writeByte(Tags.TagSemicolon);\n            return true;\n        }\n        return false;\n    } },\n    reset: { value: function () {\n        this._ref = new Map();\n        this._refcount = 0;\n    } }\n});\n\nfunction realWriterRefer(stream) {\n    return new RealWriterRefer(stream);\n}\n\nfunction Writer(stream, simple) {\n    Object.defineProperties(this, {\n        stream: { value: stream },\n        _classref: { value: Object.create(null), writable: true },\n        _fieldsref: { value: [], writable: true },\n        _refer: { value: simple ? fakeWriterRefer : realWriterRefer(stream) }\n    });\n}\n\nfunction serialize(writer, value) {\n    var stream = writer.stream;\n    if (value === undefined || value === null) {\n        stream.writeByte(Tags.TagNull);\n        return;\n    }\n    switch (value.constructor) {\n    case Function:\n        stream.writeByte(Tags.TagNull);\n        return;\n    case Number:\n        writeNumber(writer, value);\n        return;\n    case Boolean:\n        writeBoolean(writer, value);\n        return;\n    case String:\n        switch (value.length) {\n        case 0:\n            stream.writeByte(Tags.TagEmpty);\n            return;\n        case 1:\n            stream.writeByte(Tags.TagUTF8Char);\n            stream.writeString(value);\n            return;\n        }\n        writer.writeStringWithRef(value);\n        return;\n    case Date:\n        writer.writeDateWithRef(value);\n        return;\n    case Array:\n        writer.writeListWithRef(value);\n        return;\n    case Map:\n        writer.writeMapWithRef(value);\n        return;\n    case ArrayBuffer:\n    case Uint8Array:\n    case BytesIO:\n    case Buffer:\n        writer.writeBytesWithRef(value);\n        return;\n    case Int8Array:\n    case Int16Array:\n    case Int32Array:\n    case Uint16Array:\n    case Uint32Array:\n        writeIntListWithRef(writer, value);\n        return;\n    case Float32Array:\n    case Float64Array:\n        writeDoubleListWithRef(writer, value);\n        return;\n    default:\n        if (Array.isArray(value)) {\n            writer.writeListWithRef(value);\n        }\n        else if (Buffer.isBuffer(value)) {\n            writer.writeBytesWithRef(value);\n        }\n        else {\n            var classname = getClassName(value);\n            if (classname === 'Object') {\n                writer.writeMapWithRef(value);\n            }\n            else {\n                writer.writeObjectWithRef(value);\n            }\n        }\n        break;\n    }\n}\n\nfunction writeNumber(writer, n) {\n    var stream = writer.stream;\n    n = n.valueOf();\n    if (n === (n | 0)) {\n        if (0 <= n && n <= 9) {\n            stream.writeByte(n + 0x30);\n        }\n        else {\n            stream.writeByte(Tags.TagInteger);\n            stream.writeAsciiString('' + n);\n            stream.writeByte(Tags.TagSemicolon);\n        }\n    }\n    else if (isNaN(n)) {\n        stream.writeByte(Tags.TagNaN);\n    }\n    else if (isFinite(n)) {\n        stream.writeByte(Tags.TagDouble);\n        stream.writeAsciiString('' + n);\n        stream.writeByte(Tags.TagSemicolon);\n    }\n    else {\n        stream.writeByte(Tags.TagInfinity);\n        stream.writeByte((n > 0) ? Tags.TagPos : Tags.TagNeg);\n    }\n}\n\nfunction writeInteger(writer, n) {\n    var stream = writer.stream;\n    if (0 <= n && n <= 9) {\n        stream.writeByte(n + 0x30);\n    }\n    else {\n        if (n < -2147483648 || n > 2147483647) {\n            stream.writeByte(Tags.TagLong);\n        }\n        else {\n            stream.writeByte(Tags.TagInteger);\n        }\n        stream.writeAsciiString('' + n);\n        stream.writeByte(Tags.TagSemicolon);\n    }\n}\n\nfunction writeDouble(writer, n) {\n    var stream = writer.stream;\n    if (isNaN(n)) {\n        stream.writeByte(Tags.TagNaN);\n    }\n    else if (isFinite(n)) {\n        stream.writeByte(Tags.TagDouble);\n        stream.writeAsciiString('' + n);\n        stream.writeByte(Tags.TagSemicolon);\n    }\n    else {\n        stream.writeByte(Tags.TagInfinity);\n        stream.writeByte((n > 0) ? Tags.TagPos : Tags.TagNeg);\n    }\n}\n\nfunction writeBoolean(writer, b) {\n    writer.stream.writeByte(b.valueOf() ? Tags.TagTrue : Tags.TagFalse);\n}\n\nfunction writeUTCDate(writer, date) {\n    writer._refer.set(date);\n    var stream = writer.stream;\n    var year = ('0000' + date.getUTCFullYear()).slice(-4);\n    var month = ('00' + (date.getUTCMonth() + 1)).slice(-2);\n    var day = ('00' + date.getUTCDate()).slice(-2);\n    var hour = ('00' + date.getUTCHours()).slice(-2);\n    var minute = ('00' + date.getUTCMinutes()).slice(-2);\n    var second = ('00' + date.getUTCSeconds()).slice(-2);\n    var millisecond = ('000' + date.getUTCMilliseconds()).slice(-3);\n    stream.writeByte(Tags.TagDate);\n    stream.writeAsciiString(year + month + day);\n    stream.writeByte(Tags.TagTime);\n    stream.writeAsciiString(hour + minute + second);\n    if (millisecond !== '000') {\n        stream.writeByte(Tags.TagPoint);\n        stream.writeAsciiString(millisecond);\n    }\n    stream.writeByte(Tags.TagUTC);\n}\n\nfunction writeDate(writer, date) {\n    writer._refer.set(date);\n    var stream = writer.stream;\n    var year = ('0000' + date.getFullYear()).slice(-4);\n    var month = ('00' + (date.getMonth() + 1)).slice(-2);\n    var day = ('00' + date.getDate()).slice(-2);\n    var hour = ('00' + date.getHours()).slice(-2);\n    var minute = ('00' + date.getMinutes()).slice(-2);\n    var second = ('00' + date.getSeconds()).slice(-2);\n    var millisecond = ('000' + date.getMilliseconds()).slice(-3);\n    if ((hour === '00') && (minute === '00') &&\n        (second === '00') && (millisecond === '000')) {\n        stream.writeByte(Tags.TagDate);\n        stream.writeAsciiString(year + month + day);\n    }\n    else if ((year === '1970') && (month === '01') && (day === '01')) {\n        stream.writeByte(Tags.TagTime);\n        stream.writeAsciiString(hour + minute + second);\n        if (millisecond !== '000') {\n            stream.writeByte(Tags.TagPoint);\n            stream.writeAsciiString(millisecond);\n        }\n    }\n    else {\n        stream.writeByte(Tags.TagDate);\n        stream.writeAsciiString(year + month + day);\n        stream.writeByte(Tags.TagTime);\n        stream.writeAsciiString(hour + minute + second);\n        if (millisecond !== '000') {\n            stream.writeByte(Tags.TagPoint);\n            stream.writeAsciiString(millisecond);\n        }\n    }\n    stream.writeByte(Tags.TagSemicolon);\n}\n\nfunction writeTime(writer, time) {\n    writer._refer.set(time);\n    var stream = writer.stream;\n    var hour = ('00' + time.getHours()).slice(-2);\n    var minute = ('00' + time.getMinutes()).slice(-2);\n    var second = ('00' + time.getSeconds()).slice(-2);\n    var millisecond = ('000' + time.getMilliseconds()).slice(-3);\n    stream.writeByte(Tags.TagTime);\n    stream.writeAsciiString(hour + minute + second);\n    if (millisecond !== '000') {\n        stream.writeByte(Tags.TagPoint);\n        stream.writeAsciiString(millisecond);\n    }\n    stream.writeByte(Tags.TagSemicolon);\n}\n\nfunction writeBytes(writer, bytes) {\n    writer._refer.set(bytes);\n    var stream = writer.stream;\n    stream.writeByte(Tags.TagBytes);\n    var n = bytes.byteLength || bytes.length;\n    if (n > 0) {\n        stream.writeAsciiString('' + n);\n        stream.writeByte(Tags.TagQuote);\n        stream.write(bytes);\n    }\n    else {\n        stream.writeByte(Tags.TagQuote);\n    }\n    stream.writeByte(Tags.TagQuote);\n}\n\nfunction writeString(writer, str) {\n    writer._refer.set(str);\n    var stream = writer.stream;\n    var n = str.length;\n    stream.writeByte(Tags.TagString);\n    if (n > 0) {\n        stream.writeAsciiString('' + n);\n        stream.writeByte(Tags.TagQuote);\n        stream.writeString(str);\n    }\n    else {\n        stream.writeByte(Tags.TagQuote);\n    }\n    stream.writeByte(Tags.TagQuote);\n}\n\nfunction writeArray(writer, array, writeElem) {\n    writer._refer.set(array);\n    var stream = writer.stream;\n    var n = array.length;\n    stream.writeByte(Tags.TagList);\n    if (n > 0) {\n        stream.writeAsciiString('' + n);\n        stream.writeByte(Tags.TagOpenbrace);\n        for (var i = 0; i < n; i++) {\n            writeElem(writer, array[i]);\n        }\n    }\n    else {\n        stream.writeByte(Tags.TagOpenbrace);\n    }\n    stream.writeByte(Tags.TagClosebrace);\n}\n\nfunction writeIntListWithRef(writer, list) {\n    if (!writer._refer.write(list)) {\n        writeArray(writer, list, writeInteger);\n    }\n}\n\nfunction writeDoubleListWithRef(writer, list) {\n    if (!writer._refer.write(list)) {\n        writeArray(writer, list, writeDouble);\n    }\n}\n\nfunction writeMap(writer, map) {\n    writer._refer.set(map);\n    var stream = writer.stream;\n    var fields = [];\n    for (var key in map) {\n        if (map.hasOwnProperty(key) &&\n            typeof(map[key]) !== 'function') {\n            fields[fields.length] = key;\n        }\n    }\n    var n = fields.length;\n    stream.writeByte(Tags.TagMap);\n    if (n > 0) {\n        stream.writeAsciiString('' + n);\n        stream.writeByte(Tags.TagOpenbrace);\n        for (var i = 0; i < n; i++) {\n            serialize(writer, fields[i]);\n            serialize(writer, map[fields[i]]);\n        }\n    }\n    else {\n        stream.writeByte(Tags.TagOpenbrace);\n    }\n    stream.writeByte(Tags.TagClosebrace);\n}\n\nfunction writeHarmonyMap(writer, map) {\n    writer._refer.set(map);\n    var stream = writer.stream;\n    var n = map.size;\n    stream.writeByte(Tags.TagMap);\n    if (n > 0) {\n        stream.writeAsciiString('' + n);\n        stream.writeByte(Tags.TagOpenbrace);\n        map.forEach(function(value, key) {\n            serialize(writer, key);\n            serialize(writer, value);\n        });\n    }\n    else {\n        stream.writeByte(Tags.TagOpenbrace);\n    }\n    stream.writeByte(Tags.TagClosebrace);\n}\n\nfunction writeObject(writer, obj) {\n    var stream = writer.stream;\n    var classname = getClassName(obj);\n    var fields, index;\n    if (classname in writer._classref) {\n        index = writer._classref[classname];\n        fields = writer._fieldsref[index];\n    }\n    else {\n        fields = [];\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key) &&\n                typeof(obj[key]) !== 'function') {\n                fields[fields.length] = key.toString();\n            }\n        }\n        index = writeClass(writer, classname, fields);\n    }\n    stream.writeByte(Tags.TagObject);\n    stream.writeAsciiString('' + index);\n    stream.writeByte(Tags.TagOpenbrace);\n    writer._refer.set(obj);\n    var n = fields.length;\n    for (var i = 0; i < n; i++) {\n        serialize(writer, obj[fields[i]]);\n    }\n    stream.writeByte(Tags.TagClosebrace);\n}\n\nfunction writeClass(writer, classname, fields) {\n    var stream = writer.stream;\n    var n = fields.length;\n    stream.writeByte(Tags.TagClass);\n    stream.writeAsciiString('' + classname.length);\n    stream.writeByte(Tags.TagQuote);\n    stream.writeString(classname);\n    stream.writeByte(Tags.TagQuote);\n    if (n > 0) {\n        stream.writeAsciiString('' + n);\n        stream.writeByte(Tags.TagOpenbrace);\n        for (var i = 0; i < n; i++) {\n            writeString(writer, fields[i]);\n        }\n    }\n    else {\n        stream.writeByte(Tags.TagOpenbrace);\n    }\n    stream.writeByte(Tags.TagClosebrace);\n    var index = writer._fieldsref.length;\n    writer._classref[classname] = index;\n    writer._fieldsref[index] = fields;\n    return index;\n}\n\nObject.defineProperties(Writer.prototype, {\n    serialize: { value: function(value) {\n        serialize(this, value);\n    } },\n    writeInteger: { value: function(value) {\n        writeInteger(this, value);\n    } },\n    writeDouble: { value: function(value) {\n        writeDouble(this, value);\n    } },\n    writeBoolean: { value: function(value) {\n        writeBoolean(this, value);\n    } },\n    writeUTCDate: { value: function(value) {\n        writeUTCDate(this, value);\n    } },\n    writeUTCDateWithRef: { value: function(value) {\n        if (!this._refer.write(value)) {\n            writeUTCDate(this, value);\n        }\n    } },\n    writeDate: { value: function(value) {\n        writeDate(this, value);\n    } },\n    writeDateWithRef: { value: function(value) {\n        if (!this._refer.write(value)) {\n            writeDate(this, value);\n        }\n    } },\n    writeTime: { value: function(value) {\n        writeTime(this, value);\n    } },\n    writeTimeWithRef: { value: function(value) {\n        if (!this._refer.write(value)) {\n            writeTime(this, value);\n        }\n    } },\n    writeBytes: { value: function(value) {\n        writeBytes(this, value);\n    } },\n    writeBytesWithRef: { value: function(value) {\n        if (!this._refer.write(value)) {\n            writeBytes(this, value);\n        }\n    } },\n    writeString: { value: function(value) {\n        writeString(this, value);\n    } },\n    writeStringWithRef: { value: function(value) {\n        if (!this._refer.write(value)) {\n            writeString(this, value);\n        }\n    } },\n    writeList: { value: function(value) {\n        writeArray(this, value, serialize);\n    } },\n    writeListWithRef: { value: function(value) {\n        if (!this._refer.write(value)) {\n            writeArray(this, value, serialize);\n        }\n    } },\n    writeMap: { value: function(value) {\n        if (value instanceof Map) {\n            writeHarmonyMap(this, value);\n        }\n        else {\n            writeMap(this, value);\n        }\n    } },\n    writeMapWithRef: { value: function(value) {\n        if (!this._refer.write(value)) {\n            if (value instanceof Map) {\n                writeHarmonyMap(this, value);\n            }\n            else {\n                writeMap(this, value);\n            }\n        }\n    } },\n    writeObject: { value: function(value) {\n        writeObject(this, value);\n    } },\n    writeObjectWithRef: { value: function(value) {\n        if (!this._refer.write(value)) {\n            writeObject(this, value);\n        }\n    } },\n    reset: { value: function() {\n        this._classref = Object.create(null);\n        this._fieldsref.length = 0;\n        this._refer.reset();\n    } }\n});\n\nglobal.hprose.Writer = Writer;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/io/Reader.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/io/Reader.js                                    *\n *                                                        *\n * Hprose Reader for Node.js.                             *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar Map = global.Map;\nvar BytesIO = global.hprose.BytesIO;\nvar Tags = global.hprose.Tags;\nvar ClassManager = global.hprose.ClassManager;\n\nfunction unexpectedTag(tag, expectTags) {\n    if (tag && expectTags) {\n        var expectTagStr = '';\n        if (typeof(expectTags) === 'number') {\n            expectTagStr = String.fromCharCode(expectTags);\n        }\n        else {\n            expectTagStr = String.fromCharCode.apply(String, expectTags);\n        }\n        throw new Error('Tag \"' + expectTagStr + '\" expected, but \"' + String.fromCharCode(tag) + '\" found in stream');\n    }\n    else if (tag) {\n        throw new Error('Unexpected serialize tag \"' + String.fromCharCode(tag) + '\" in stream');\n    }\n    else {\n        throw new Error('No byte found in stream');\n    }\n}\n\nfunction readRaw(stream) {\n    var ostream = new BytesIO();\n    _readRaw(stream, ostream);\n    return ostream.bytes;\n}\n\nfunction _readRaw(stream, ostream) {\n    __readRaw(stream, ostream, stream.readByte());\n}\n\nfunction __readRaw(stream, ostream, tag) {\n    ostream.writeByte(tag);\n    switch (tag) {\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n        case Tags.TagNull:\n        case Tags.TagEmpty:\n        case Tags.TagTrue:\n        case Tags.TagFalse:\n        case Tags.TagNaN:\n            break;\n        case Tags.TagInfinity:\n            ostream.writeByte(stream.readByte());\n            break;\n        case Tags.TagInteger:\n        case Tags.TagLong:\n        case Tags.TagDouble:\n        case Tags.TagRef:\n            readNumberRaw(stream, ostream);\n            break;\n        case Tags.TagDate:\n        case Tags.TagTime:\n            readDateTimeRaw(stream, ostream);\n            break;\n        case Tags.TagUTF8Char:\n            readUTF8CharRaw(stream, ostream);\n            break;\n        case Tags.TagBytes:\n            readBytesRaw(stream, ostream);\n            break;\n        case Tags.TagString:\n            readStringRaw(stream, ostream);\n            break;\n        case Tags.TagGuid:\n            readGuidRaw(stream, ostream);\n            break;\n        case Tags.TagList:\n        case Tags.TagMap:\n        case Tags.TagObject:\n            readComplexRaw(stream, ostream);\n            break;\n        case Tags.TagClass:\n            readComplexRaw(stream, ostream);\n            _readRaw(stream, ostream);\n            break;\n        case Tags.TagError:\n            _readRaw(stream, ostream);\n            break;\n        default: unexpectedTag(tag);\n    }\n}\nfunction readNumberRaw(stream, ostream) {\n    var tag;\n    do {\n        tag = stream.readByte();\n        ostream.writeByte(tag);\n    } while (tag !== Tags.TagSemicolon);\n}\nfunction readDateTimeRaw(stream, ostream) {\n    var tag;\n    do {\n        tag = stream.readByte();\n        ostream.writeByte(tag);\n    } while (tag !== Tags.TagSemicolon &&\n             tag !== Tags.TagUTC);\n}\nfunction readUTF8CharRaw(stream, ostream) {\n    ostream.writeString(stream.readString(1));\n}\nfunction readBytesRaw(stream, ostream) {\n    var count = 0;\n    var tag = 48;\n    do {\n        count *= 10;\n        count += tag - 48;\n        tag = stream.readByte();\n        ostream.writeByte(tag);\n    } while (tag !== Tags.TagQuote);\n    ostream.write(stream.read(count + 1));\n}\nfunction readStringRaw(stream, ostream) {\n    var count = 0;\n    var tag = 48;\n    do {\n        count *= 10;\n        count += tag - 48;\n        tag = stream.readByte();\n        ostream.writeByte(tag);\n    } while (tag !== Tags.TagQuote);\n    ostream.write(stream.readStringAsBytes(count + 1));\n}\nfunction readGuidRaw(stream, ostream) {\n    ostream.write(stream.read(38));\n}\nfunction readComplexRaw(stream, ostream) {\n    var tag;\n    do {\n        tag = stream.readByte();\n        ostream.writeByte(tag);\n    } while (tag !== Tags.TagOpenbrace);\n    while ((tag = stream.readByte()) !== Tags.TagClosebrace) {\n        __readRaw(stream, ostream, tag);\n    }\n    ostream.writeByte(tag);\n}\n\nfunction RawReader(stream) {\n    Object.defineProperties(this, {\n        stream: { value : stream },\n        readRaw: { value: function() { return readRaw(stream); } }\n    });\n}\n\nglobal.hprose.RawReader = RawReader;\n\nvar fakeReaderRefer = Object.create(null, {\n    set: { value: function() {} },\n    read: { value: function() { unexpectedTag(Tags.TagRef); } },\n    reset: { value: function() {} }\n});\n\nfunction RealReaderRefer() {\n    Object.defineProperties(this, {\n        ref: { value: [] }\n    });\n}\n\nObject.defineProperties(RealReaderRefer.prototype, {\n    set: { value: function(val) { this.ref[this.ref.length] = val; } },\n    read: { value: function(index) { return this.ref[index]; } },\n    reset: { value: function() { this.ref.length = 0; } }\n});\n\nfunction realReaderRefer() {\n    return new RealReaderRefer();\n}\n\nfunction getter(str) {\n    var obj = global;\n    var names = str.split('.');\n    var i;\n    for (i = 0; i < names.length; i++) {\n        obj = obj[names[i]];\n        if (obj === undefined) {\n            return null;\n        }\n    }\n    return obj;\n}\nfunction findClass(cn, poslist, i, c) {\n    if (i < poslist.length) {\n        var pos = poslist[i];\n        cn[pos] = c;\n        var cls = findClass(cn, poslist, i + 1, '.');\n        if (i + 1 < poslist.length) {\n            if (cls === null) {\n                cls = findClass(cn, poslist, i + 1, '_');\n            }\n        }\n        return cls;\n    }\n    var classname = cn.join('');\n    try {\n        var cl = getter(classname);\n        return ((typeof(cl) === 'function') ? cl : null);\n    } catch (e) {\n        return null;\n    }\n}\nfunction getClass(classname) {\n    var cls = ClassManager.getClass(classname);\n    if (cls) { return cls; }\n    cls = getter(classname);\n    if (typeof(cls) === 'function') {\n        ClassManager.register(cls, classname);\n        return cls;\n    }\n    var poslist = [];\n    var pos = classname.indexOf('_');\n    while (pos >= 0) {\n        poslist[poslist.length] = pos;\n        pos = classname.indexOf('_', pos + 1);\n    }\n    if (poslist.length > 0) {\n        var cn = classname.split('');\n        cls = findClass(cn, poslist, 0, '.');\n        if (cls === null) {\n            cls = findClass(cn, poslist, 0, '_');\n        }\n        if (typeof(cls) === 'function') {\n            ClassManager.register(cls, classname);\n            return cls;\n        }\n    }\n    cls = function () {};\n    Object.defineProperty(cls.prototype, 'getClassName', { value: function () {\n        return classname;\n    }});\n    ClassManager.register(cls, classname);\n    return cls;\n}\n\nfunction readInt(stream, tag) {\n    var s = stream.readUntil(tag);\n    if (s.length === 0) return 0;\n    return parseInt(s, 10);\n}\nfunction unserialize(reader) {\n    var stream = reader.stream;\n    var tag = stream.readByte();\n    switch (tag) {\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57: return tag - 48;\n        case Tags.TagInteger: return readIntegerWithoutTag(stream);\n        case Tags.TagLong: return readLongWithoutTag(stream);\n        case Tags.TagDouble: return readDoubleWithoutTag(stream);\n        case Tags.TagNull: return null;\n        case Tags.TagEmpty: return '';\n        case Tags.TagTrue: return true;\n        case Tags.TagFalse: return false;\n        case Tags.TagNaN: return NaN;\n        case Tags.TagInfinity: return readInfinityWithoutTag(stream);\n        case Tags.TagDate: return readDateWithoutTag(reader);\n        case Tags.TagTime: return readTimeWithoutTag(reader);\n        case Tags.TagBytes: return readBytesWithoutTag(reader);\n        case Tags.TagUTF8Char: return readUTF8CharWithoutTag(reader);\n        case Tags.TagString: return readStringWithoutTag(reader);\n        case Tags.TagGuid: return readGuidWithoutTag(reader);\n        case Tags.TagList: return readListWithoutTag(reader);\n        case Tags.TagMap: return reader.useHarmonyMap ? readHarmonyMapWithoutTag(reader) : readMapWithoutTag(reader);\n        case Tags.TagClass: readClass(reader); return readObject(reader);\n        case Tags.TagObject: return readObjectWithoutTag(reader);\n        case Tags.TagRef: return readRef(reader);\n        case Tags.TagError: throw new Error(readString(reader));\n        default: unexpectedTag(tag);\n    }\n}\nfunction readIntegerWithoutTag(stream) {\n    return readInt(stream, Tags.TagSemicolon);\n}\nfunction readInteger(stream) {\n    var tag = stream.readByte();\n    switch (tag) {\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57: return tag - 48;\n        case Tags.TagInteger: return readIntegerWithoutTag(stream);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readLongWithoutTag(stream) {\n    var s = stream.readUntil(Tags.TagSemicolon);\n    var l = parseInt(s, 10);\n    if (l.toString() === s) return l;\n    return s;\n}\nfunction readLong(stream) {\n    var tag = stream.readByte();\n    switch (tag) {\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57: return tag - 48;\n        case Tags.TagInteger:\n        case Tags.TagLong: return readLongWithoutTag(stream);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readDoubleWithoutTag(stream) {\n    return parseFloat(stream.readUntil(Tags.TagSemicolon));\n}\nfunction readDouble(stream) {\n    var tag = stream.readByte();\n    switch (tag) {\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57: return tag - 48;\n        case Tags.TagInteger:\n        case Tags.TagLong:\n        case Tags.TagDouble: return readDoubleWithoutTag(stream);\n        case Tags.TagNaN: return NaN;\n        case Tags.TagInfinity: return readInfinityWithoutTag(stream);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readInfinityWithoutTag(stream) {\n    return ((stream.readByte() === Tags.TagNeg) ? -Infinity : Infinity);\n}\nfunction readBoolean(stream) {\n    var tag = stream.readByte();\n    switch (tag) {\n        case Tags.TagTrue: return true;\n        case Tags.TagFalse: return false;\n        default: unexpectedTag(tag);\n    }\n}\nfunction readDateWithoutTag(reader) {\n    var stream = reader.stream;\n    var year = parseInt(stream.readAsciiString(4), 10);\n    var month = parseInt(stream.readAsciiString(2), 10) - 1;\n    var day = parseInt(stream.readAsciiString(2), 10);\n    var date;\n    var tag = stream.readByte();\n    if (tag === Tags.TagTime) {\n        var hour = parseInt(stream.readAsciiString(2), 10);\n        var minute = parseInt(stream.readAsciiString(2), 10);\n        var second = parseInt(stream.readAsciiString(2), 10);\n        var millisecond = 0;\n        tag = stream.readByte();\n        if (tag === Tags.TagPoint) {\n            millisecond = parseInt(stream.readAsciiString(3), 10);\n            tag = stream.readByte();\n            if ((tag >= 48) && (tag <= 57)) {\n                stream.skip(2);\n                tag = stream.readByte();\n                if ((tag >= 48) && (tag <= 57)) {\n                    stream.skip(2);\n                    tag = stream.readByte();\n                }\n            }\n        }\n        if (tag === Tags.TagUTC) {\n            date = new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));\n        }\n        else {\n            date = new Date(year, month, day, hour, minute, second, millisecond);\n        }\n    }\n    else if (tag === Tags.TagUTC) {\n        date = new Date(Date.UTC(year, month, day));\n    }\n    else {\n        date = new Date(year, month, day);\n    }\n    reader.refer.set(date);\n    return date;\n}\nfunction readDate(reader) {\n    var tag = reader.stream.readByte();\n    switch (tag) {\n        case Tags.TagNull: return null;\n        case Tags.TagDate: return readDateWithoutTag(reader);\n        case Tags.TagRef: return readRef(reader);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readTimeWithoutTag(reader) {\n    var stream = reader.stream;\n    var time;\n    var hour = parseInt(stream.readAsciiString(2), 10);\n    var minute = parseInt(stream.readAsciiString(2), 10);\n    var second = parseInt(stream.readAsciiString(2), 10);\n    var millisecond = 0;\n    var tag = stream.readByte();\n    if (tag === Tags.TagPoint) {\n        millisecond = parseInt(stream.readAsciiString(3), 10);\n        tag = stream.readByte();\n        if ((tag >= 48) && (tag <= 57)) {\n            stream.skip(2);\n            tag = stream.readByte();\n            if ((tag >= 48) && (tag <= 57)) {\n                stream.skip(2);\n                tag = stream.readByte();\n            }\n        }\n    }\n    if (tag === Tags.TagUTC) {\n        time = new Date(Date.UTC(1970, 0, 1, hour, minute, second, millisecond));\n    }\n    else {\n        time = new Date(1970, 0, 1, hour, minute, second, millisecond);\n    }\n    reader.refer.set(time);\n    return time;\n}\nfunction readTime(reader) {\n    var tag = reader.stream.readByte();\n    switch (tag) {\n        case Tags.TagNull: return null;\n        case Tags.TagTime: return readTimeWithoutTag(reader);\n        case Tags.TagRef: return readRef(reader);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readBytesWithoutTag(reader) {\n    var stream = reader.stream;\n    var count = readInt(stream, Tags.TagQuote);\n    var bytes = stream.read(count);\n    stream.skip(1);\n    reader.refer.set(bytes);\n    return bytes;\n}\nfunction readBytes(reader) {\n    var tag = reader.stream.readByte();\n    switch (tag) {\n        case Tags.TagNull: return null;\n        case Tags.TagEmpty: return new Uint8Array(0);\n        case Tags.TagBytes: return readBytesWithoutTag(reader);\n        case Tags.TagRef: return readRef(reader);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readUTF8CharWithoutTag(reader) {\n    return reader.stream.readString(1);\n}\nfunction _readString(reader) {\n    var stream = reader.stream;\n    var s = stream.readString(readInt(stream, Tags.TagQuote));\n    stream.skip(1);\n    return s;\n}\nfunction readStringWithoutTag(reader) {\n    var s = _readString(reader);\n    reader.refer.set(s);\n    return s;\n}\nfunction readString(reader) {\n    var tag = reader.stream.readByte();\n    switch (tag) {\n        case Tags.TagNull: return null;\n        case Tags.TagEmpty: return '';\n        case Tags.TagUTF8Char: return readUTF8CharWithoutTag(reader);\n        case Tags.TagString: return readStringWithoutTag(reader);\n        case Tags.TagRef: return readRef(reader);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readGuidWithoutTag(reader) {\n    var stream = reader.stream;\n    stream.skip(1);\n    var s = stream.readAsciiString(36);\n    stream.skip(1);\n    reader.refer.set(s);\n    return s;\n}\nfunction readGuid(reader) {\n    var tag = reader.stream.readByte();\n    switch (tag) {\n        case Tags.TagNull: return null;\n        case Tags.TagGuid: return readGuidWithoutTag(reader);\n        case Tags.TagRef: return readRef(reader);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readListWithoutTag(reader) {\n    var stream = reader.stream;\n    var list = [];\n    reader.refer.set(list);\n    var count = readInt(stream, Tags.TagOpenbrace);\n    for (var i = 0; i < count; i++) {\n        list[i] = unserialize(reader);\n    }\n    stream.skip(1);\n    return list;\n}\nfunction readList(reader) {\n    var tag = reader.stream.readByte();\n    switch (tag) {\n        case Tags.TagNull: return null;\n        case Tags.TagList: return readListWithoutTag(reader);\n        case Tags.TagRef: return readRef(reader);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readMapWithoutTag(reader) {\n    var stream = reader.stream;\n    var map = {};\n    reader.refer.set(map);\n    var count = readInt(stream, Tags.TagOpenbrace);\n    for (var i = 0; i < count; i++) {\n        var key = unserialize(reader);\n        var value = unserialize(reader);\n        map[key] = value;\n    }\n    stream.skip(1);\n    return map;\n}\nfunction readMap(reader) {\n    var tag = reader.stream.readByte();\n    switch (tag) {\n        case Tags.TagNull: return null;\n        case Tags.TagMap: return readMapWithoutTag(reader);\n        case Tags.TagRef: return readRef(reader);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readHarmonyMapWithoutTag(reader) {\n    var stream = reader.stream;\n    var map = new Map();\n    reader.refer.set(map);\n    var count = readInt(stream, Tags.TagOpenbrace);\n    for (var i = 0; i < count; i++) {\n        var key = unserialize(reader);\n        var value = unserialize(reader);\n        map.set(key, value);\n    }\n    stream.skip(1);\n    return map;\n}\nfunction readHarmonyMap(reader) {\n    var tag = reader.stream.readByte();\n    switch (tag) {\n        case Tags.TagNull: return null;\n        case Tags.TagMap: return readHarmonyMapWithoutTag(reader);\n        case Tags.TagRef: return readRef(reader);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readObjectWithoutTag(reader) {\n    var stream = reader.stream;\n    var cls = reader.classref[readInt(stream, Tags.TagOpenbrace)];\n    var obj = new cls.classname();\n    reader.refer.set(obj);\n    for (var i = 0; i < cls.count; i++) {\n        obj[cls.fields[i]] = unserialize(reader);\n    }\n    stream.skip(1);\n    return obj;\n}\nfunction readObject(reader) {\n    var tag = reader.stream.readByte();\n    switch(tag) {\n        case Tags.TagNull: return null;\n        case Tags.TagClass: readClass(reader); return readObject(reader);\n        case Tags.TagObject: return readObjectWithoutTag(reader);\n        case Tags.TagRef: return readRef(reader);\n        default: unexpectedTag(tag);\n    }\n}\nfunction readClass(reader) {\n    var stream = reader.stream;\n    var classname = _readString(reader);\n    var count = readInt(stream, Tags.TagOpenbrace);\n    var fields = [];\n    for (var i = 0; i < count; i++) {\n        fields[i] = readString(reader);\n    }\n    stream.skip(1);\n    classname = getClass(classname);\n    reader.classref.push({\n        classname: classname,\n        count: count,\n        fields: fields\n    });\n}\nfunction readRef(reader) {\n    return reader.refer.read(readInt(reader.stream, Tags.TagSemicolon));\n}\n\nfunction Reader(stream, simple, useHarmonyMap) {\n    RawReader.call(this, stream);\n    this.useHarmonyMap = !!useHarmonyMap;\n    Object.defineProperties(this, {\n        classref: { value: [] },\n        refer: { value: simple ? fakeReaderRefer : realReaderRefer() }\n    });\n}\n\nReader.prototype = Object.create(RawReader.prototype);\nReader.prototype.constructor = Reader;\n\nObject.defineProperties(Reader.prototype, {\n    useHarmonyMap: { value: false, writable: true },\n    checkTag: { value: function(expectTag, tag) {\n        if (tag === undefined) { tag = this.stream.readByte(); }\n        if (tag !== expectTag) { unexpectedTag(tag, expectTag); }\n    } },\n    checkTags: { value: function(expectTags, tag) {\n        if (tag === undefined) { tag = this.stream.readByte(); }\n        if (expectTags.indexOf(tag) >= 0) { return tag; }\n        unexpectedTag(tag, expectTags);\n    } },\n    unserialize: { value: function() {\n        return unserialize(this);\n    } },\n    readInteger: { value: function() {\n        return readInteger(this.stream);\n    } },\n    readLong: { value: function() {\n        return readLong(this.stream);\n    } },\n    readDouble: { value: function() {\n        return readDouble(this.stream);\n    } },\n    readBoolean: { value: function() {\n        return readBoolean(this.stream);\n    } },\n    readDateWithoutTag: { value: function() {\n        return readDateWithoutTag(this);\n    } },\n    readDate: { value: function() {\n        return readDate(this);\n    } },\n    readTimeWithoutTag: { value: function() {\n        return readTimeWithoutTag(this);\n    } },\n    readTime: { value: function() {\n        return readTime(this);\n    } },\n    readBytesWithoutTag: { value: function() {\n        return readBytesWithoutTag(this);\n    } },\n    readBytes: { value: function() {\n        return readBytes(this);\n    } },\n    readStringWithoutTag: { value: function() {\n        return readStringWithoutTag(this);\n    } },\n    readString: { value: function() {\n        return readString(this);\n    } },\n    readGuidWithoutTag: { value: function() {\n        return readGuidWithoutTag(this);\n    } },\n    readGuid: { value: function() {\n        return readGuid(this);\n    } },\n    readListWithoutTag: { value: function() {\n        return readListWithoutTag(this);\n    } },\n    readList: { value: function() {\n        return readList(this);\n    } },\n    readMapWithoutTag: { value: function() {\n        return this.useHarmonyMap ?\n               readHarmonyMapWithoutTag(this) :\n               readMapWithoutTag(this);\n    } },\n    readMap: { value: function() {\n        return this.useHarmonyMap ?\n               readHarmonyMap(this) :\n               readMap(this);\n    } },\n    readObjectWithoutTag: { value: function() {\n        return readObjectWithoutTag(this);\n    } },\n    readObject: { value: function() {\n        return readObject(this);\n    } },\n    reset: { value: function() {\n        this.classref.length = 0;\n        this.refer.reset();\n    } }\n});\n\nglobal.hprose.Reader = Reader;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/io/Formatter.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/io/Formatter.js                                 *\n *                                                        *\n * Hprose Formatter for Node.js.                          *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar BytesIO = global.hprose.BytesIO;\nvar Writer = global.hprose.Writer;\nvar Reader = global.hprose.Reader;\n\nfunction serialize(value, simple) {\n    var stream = new BytesIO();\n    var writer = new Writer(stream, simple);\n    writer.serialize(value);\n    return stream;\n}\n\nfunction unserialize(stream, simple, useHarmonyMap) {\n    if (!(stream instanceof BytesIO)) {\n        stream = new BytesIO(stream);\n    }\n    return new Reader(stream, simple, useHarmonyMap).unserialize();\n}\n\nglobal.hprose.Formatter = {\n    serialize: function (value, simple) {\n        return serialize(value, simple).bytes;\n    },\n    unserialize: unserialize\n};\n\nglobal.hprose.serialize = serialize;\n\nglobal.hprose.unserialize = unserialize;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/client/Client.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/client/Client.js                                *\n *                                                        *\n * HproseClient for Node.js.                              *\n *                                                        *\n * LastModified: Nov 19, 2016                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n/* global Proxy */\n'use strict';\n\nvar util = require('util');\nvar parse = require('url').parse;\nvar EventEmitter = require('events').EventEmitter;\n\nvar Tags = global.hprose.Tags;\nvar ResultMode = global.hprose.ResultMode;\nvar BytesIO = global.hprose.BytesIO;\nvar Writer = global.hprose.Writer;\nvar Reader = global.hprose.Reader;\nvar Future = global.hprose.Future;\nvar slice = Function.prototype.call.bind(Array.prototype.slice);\nvar isObjectEmpty = global.hprose.isObjectEmpty;\n\nvar GETFUNCTIONS = new Uint8Array(1);\nGETFUNCTIONS[0] = Tags.TagEnd;\n\nfunction noop(){}\n\nvar s_boolean = 'boolean';\nvar s_string = 'string';\nvar s_number = 'number';\nvar s_function = 'function';\nvar s_object = 'object';\n\nfunction HproseProxy(setFunction, ns) {\n    this.get = function(proxy, name) {\n        if (ns) { name = ns + '_' + name; }\n        return Proxy.createFunction(\n            new HproseProxy(setFunction, name),\n            setFunction(this, name)\n        );\n    };\n}\n\nfunction Client(uri, functions, settings) {\n    EventEmitter.call(this);\n    this.on('error', noop);\n\n    // private members\n    var _uri,\n        _uriList                = [],\n        _index                  = -1,\n        _byref                  = false,\n        _simple                 = false,\n        _timeout                = 30000,\n        _retry                  = 10,\n        _idempotent             = false,\n        _failswitch             = false,\n        _failround              = 0,\n        _lock                   = false,\n        _tasks                  = [],\n        _useHarmonyMap          = false,\n        _onerror                = noop,\n        _onfailswitch           = noop,\n        _filters                = [],\n        _batch                  = false,\n        _batches                = [],\n        _ready                  = new Future(),\n        _topics                 = Object.create(null),\n        _id                     = null,\n        _keepAlive              = true,\n        _invokeHandler          = invokeHandler,\n        _batchInvokeHandler     = batchInvokeHandler,\n        _beforeFilterHandler    = beforeFilterHandler,\n        _afterFilterHandler     = afterFilterHandler,\n        _invokeHandlers         = [],\n        _batchInvokeHandlers    = [],\n        _beforeFilterHandlers   = [],\n        _afterFilterHandlers    = [],\n        _options                = Object.create(null),\n\n        self = this;\n\n    function outputFilter(request, context) {\n        for (var i = 0, n = _filters.length; i < n; i++) {\n            request = _filters[i].outputFilter(request, context);\n        }\n        return request;\n    }\n\n    function inputFilter(response, context) {\n        for (var i = _filters.length - 1; i >= 0; i--) {\n            response = _filters[i].inputFilter(response, context);\n        }\n        return response;\n    }\n\n    function beforeFilterHandler(request, context) {\n        request = outputFilter(request, context);\n        return _afterFilterHandler(request, context)\n        .then(function(response) {\n            if (context.oneway) { return; }\n            return inputFilter(response, context);\n        });\n    }\n\n    function afterFilterHandler(request, context) {\n         return self.sendAndReceive(request, context).catchError(function(e) {\n             var response = retry(request, context);\n             if (response !== null) {\n                 return response;\n             }\n             throw e;\n        });\n    }\n\n    function sendAndReceive(request, context, onsuccess, onerror) {\n        _beforeFilterHandler(request, context).then(onsuccess, onerror);\n    }\n\n    function failswitch() {\n        var n = _uriList.length;\n        if (n > 1) {\n            var i = _index + 1;\n            if (i >= n) {\n                i = 0;\n                _failround++;\n            }\n            _index = i;\n            _uri = _uriList[_index];\n        }\n        else {\n            _failround++;\n        }\n        _onfailswitch(self);\n        self.emit('failswitch', self);\n    }\n\n    function retry(data, context) {\n        if (context.failswitch) {\n            failswitch();\n        }\n        if (context.idempotent && (context.retried < context.retry)) {\n            var interval = ++context.retried * 500;\n            if (context.failswitch) {\n                interval -= (_uriList.length - 1) * 500;\n            }\n            if (interval > 5000) {\n                interval = 5000;\n            }\n            if (interval > 0) {\n                return Future.delayed(interval, function() {\n                    return afterFilterHandler(data, context);\n                });\n            }\n            else {\n                return afterFilterHandler(data, context);\n            }\n        }\n        return null;\n    }\n\n    function initService(stub) {\n        var context = {\n            retry: _retry,\n            retried: 0,\n            idempotent: true,\n            failswitch: true,\n            timeout: _timeout,\n            client: self,\n            userdata: {}\n        };\n        var onsuccess = function(data) {\n            var error = null;\n            try {\n                var stream = new BytesIO(data);\n                var reader = new Reader(stream, true);\n                var tag = stream.readByte();\n                switch (tag) {\n                    case Tags.TagError:\n                        error = new Error(reader.readString());\n                        break;\n                    case Tags.TagFunctions:\n                        var functions = reader.readList();\n                        reader.checkTag(Tags.TagEnd);\n                        setFunctions(stub, functions);\n                        break;\n                    default:\n                        error = new Error('Wrong Response:\\r\\n' + BytesIO.toString(data));\n                        break;\n                }\n            }\n            catch (e) {\n                error = e;\n            }\n            if (error !== null) {\n                _ready.reject(error);\n            }\n            else {\n                _ready.resolve(stub);\n            }\n        };\n        sendAndReceive(GETFUNCTIONS, context, onsuccess, _ready.reject);\n    }\n\n    function setFunction(stub, name) {\n        return function() {\n            if (_batch) {\n                return _invoke(stub, name, slice(arguments), true);\n            }\n            else {\n                return Future.all(arguments).then(function(args) {\n                    return _invoke(stub, name, args, false);\n                });\n            }\n        };\n    }\n\n    function setMethods(stub, obj, namespace, name, methods) {\n        if (obj[name] !== undefined) { return; }\n        obj[name] = {};\n        if (typeof(methods) === s_string || methods.constructor === Object) {\n            methods = [methods];\n        }\n        if (Array.isArray(methods)) {\n            for (var i = 0; i < methods.length; i++) {\n                var m = methods[i];\n                if (typeof(m) === s_string) {\n                    obj[name][m] = setFunction(stub, namespace + name + '_' + m);\n                }\n                else {\n                    for (var n in m) {\n                        setMethods(stub, obj[name], namespace + name + '_', n, m[n]);\n                    }\n                }\n            }\n        }\n    }\n\n    function setFunctions(stub, functions) {\n        for (var i = 0; i < functions.length; i++) {\n            var f = functions[i];\n            if (typeof(f) === s_string) {\n                if (stub[f] === undefined) {\n                    stub[f] = setFunction(stub, f);\n                }\n            }\n            else {\n                for (var name in f) {\n                    setMethods(stub, stub, '', name, f[name]);\n                }\n            }\n        }\n    }\n\n    function copyargs(src, dest) {\n        var n = Math.min(src.length, dest.length);\n        for (var i = 0; i < n; ++i) { dest[i] = src[i]; }\n    }\n\n    function initContext(batch) {\n        if (batch) {\n            return {\n                mode: ResultMode.Normal,\n                byref: _byref,\n                simple: _simple,\n                onsuccess: undefined,\n                onerror: undefined,\n                useHarmonyMap: _useHarmonyMap,\n                client: self,\n                userdata: {}\n            };\n        }\n        return {\n            mode: ResultMode.Normal,\n            byref: _byref,\n            simple: _simple,\n            timeout: _timeout,\n            retry: _retry,\n            retried: 0,\n            idempotent: _idempotent,\n            failswitch: _failswitch,\n            oneway: false,\n            sync: false,\n            onsuccess: undefined,\n            onerror: undefined,\n            useHarmonyMap: _useHarmonyMap,\n            client: self,\n            userdata: {}\n        };\n    }\n\n    function getContext(stub, name, args, batch) {\n        var context = initContext(batch);\n        if (name in stub) {\n            var method = stub[name];\n            for (var key in method) {\n                if (key in context) {\n                    context[key] = method[key];\n                }\n            }\n        }\n        var i = 0, n = args.length;\n        for (; i < n; ++i) {\n            if (typeof args[i] === s_function) { break; }\n        }\n        if (i === n) { return context; }\n        var extra = args.splice(i, n - i);\n        context.onsuccess = extra[0];\n        n = extra.length;\n        for (i = 1; i < n; ++i) {\n            var arg = extra[i];\n            switch (typeof arg) {\n            case s_function:\n                context.onerror = arg; break;\n            case s_boolean:\n                context.byref = arg; break;\n            case s_number:\n                context.mode = arg; break;\n            case s_object:\n                for (var k in arg) {\n                    if (k in context) {\n                        context[k] = arg[k];\n                    }\n                }\n                break;\n            }\n        }\n        return context;\n    }\n\n    function encode(name, args, context) {\n        var stream = new BytesIO();\n        stream.writeByte(Tags.TagCall);\n        var writer = new Writer(stream, context.simple);\n        writer.writeString(name);\n        if (args.length > 0 || context.byref) {\n            writer.reset();\n            writer.writeList(args);\n            if (context.byref) {\n                writer.writeBoolean(true);\n            }\n        }\n        return stream;\n    }\n\n    function __invoke(name, args, context, batch) {\n        if (_lock) {\n            return Future.promise(function(resolve, reject) {\n                _tasks.push({\n                    batch: batch,\n                    name: name,\n                    args: args,\n                    context: context,\n                    resolve: resolve,\n                    reject: reject\n                });\n            });\n        }\n        if (batch) {\n            return multicall(name, args, context);\n        }\n        return call(name, args, context);\n    }\n\n    function _invoke(stub, name, args, batch) {\n        return __invoke(name, args, getContext(stub, name, args, batch), batch);\n    }\n\n    function errorHandling(name, error, context, reject) {\n        try {\n            if (context.onerror) {\n                context.onerror(name, error);\n            }\n            else {\n                _onerror(name, error);\n                self.emit('error', name, error);\n            }\n            reject(error);\n        }\n        catch (e) {\n            reject(e);\n        }\n    }\n\n    function invokeHandler(name, args, context) {\n        var request = encode(name, args, context);\n        request.writeByte(Tags.TagEnd);\n        return Future.promise(function(resolve, reject) {\n            sendAndReceive(request.bytes, context, function(response) {\n                if (context.oneway) {\n                    resolve();\n                    return;\n                }\n                var result = null;\n                var error = null;\n                try {\n                    if (context.mode === ResultMode.RawWithEndTag) {\n                        result = response;\n                    }\n                    else if (context.mode === ResultMode.Raw) {\n                        result = response.subarray(0, response.byteLength - 1);\n                    }\n                    else {\n                        var stream = new BytesIO(response);\n                        var reader = new Reader(stream, false, context.useHarmonyMap);\n                        var tag = stream.readByte();\n                        if (tag === Tags.TagResult) {\n                            if (context.mode === ResultMode.Serialized) {\n                                result = reader.readRaw();\n                            }\n                            else {\n                                result = reader.unserialize();\n                            }\n                            tag = stream.readByte();\n                            if (tag === Tags.TagArgument) {\n                                reader.reset();\n                                var _args = reader.readList();\n                                copyargs(_args, args);\n                                tag = stream.readByte();\n                            }\n                        }\n                        else if (tag === Tags.TagError) {\n                            error = new Error(reader.readString());\n                            tag = stream.readByte();\n                        }\n                        if (tag !== Tags.TagEnd) {\n                            error = new Error('Wrong Response:\\r\\n' + BytesIO.toString(response));\n                        }\n                    }\n                }\n                catch (e) {\n                    error = e;\n                }\n                if (error) {\n                    reject(error);\n                }\n                else {\n                    resolve(result);\n                }\n            }, reject);\n        });\n    }\n\n    function unlock(sync) {\n        return function() {\n            if (sync) {\n                _lock = false;\n                process.nextTick(function(tasks) {\n                    tasks.forEach(function(task) {\n                        if ('settings' in task) {\n                            endBatch(task.settings)\n                            .then(task.resolve, task.reject);\n                        }\n                        else {\n                            __invoke(task.name, task.args, task.context, task.batch).then(task.resolve, task.reject);\n                        }\n                    });\n                }, _tasks);\n                _tasks = [];\n            }\n        };\n    }\n\n    function call(name, args, context) {\n        if (context.sync) { _lock = true; }\n        var promise = Future.promise(function(resolve, reject) {\n            _invokeHandler(name, args, context).then(function(result) {\n                try {\n                    if (context.onsuccess) {\n                        try {\n                            context.onsuccess(result, args);\n                        }\n                        catch (e) {\n                            if (context.onerror) {\n                                context.onerror(name, e);\n                            }\n                            reject(e);\n                        }\n                    }\n                    resolve(result);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            }, function(error) {\n                errorHandling(name, error, context, reject);\n            });\n        });\n        promise.whenComplete(unlock(context.sync));\n        return promise;\n    }\n\n    function multicall(name, args, context) {\n        return Future.promise(function(resolve, reject) {\n            _batches.push({\n                args: args,\n                name: name,\n                context: context,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n    }\n\n    function getBatchContext(settings) {\n        var context = {\n            timeout: _timeout,\n            retry: _retry,\n            retried: 0,\n            idempotent: _idempotent,\n            failswitch: _failswitch,\n            oneway: false,\n            sync: false,\n            client: self,\n            userdata: {}\n        };\n        for (var k in settings) {\n            if (k in context) {\n                context[k] = settings[k];\n            }\n        }\n        return context;\n    }\n\n    function batchInvokeHandler(batches, context) {\n        var request = batches.reduce(function(stream, item) {\n            stream.write(encode(item.name, item.args, item.context));\n            return stream;\n        }, new BytesIO());\n        request.writeByte(Tags.TagEnd);\n        return Future.promise(function(resolve, reject) {\n            sendAndReceive(request.bytes, context, function(response) {\n                if (context.oneway) {\n                    resolve(batches);\n                    return;\n                }\n                var i = -1;\n                var stream = new BytesIO(response);\n                var reader = new Reader(stream, false);\n                var tag = stream.readByte();\n                try {\n                    while (tag !== Tags.TagEnd) {\n                        var result = null;\n                        var error = null;\n                        var mode = batches[++i].context.mode;\n                        if (mode >= ResultMode.Raw) {\n                            result = new BytesIO();\n                        }\n                        if (tag === Tags.TagResult) {\n                            if (mode === ResultMode.Serialized) {\n                                result = reader.readRaw();\n                            }\n                            else if (mode >= ResultMode.Raw) {\n                                result.writeByte(Tags.TagResult);\n                                result.write(reader.readRaw());\n                            }\n                            else {\n                                reader.useHarmonyMap = batches[i].context.useHarmonyMap;\n                                reader.reset();\n                                result = reader.unserialize();\n                            }\n                            tag = stream.readByte();\n                            if (tag === Tags.TagArgument) {\n                                if (mode >= ResultMode.Raw) {\n                                    result.writeByte(Tags.TagArgument);\n                                    result.write(reader.readRaw());\n                                }\n                                else {\n                                    reader.reset();\n                                    var _args = reader.readList();\n                                    copyargs(_args, batches[i].args);\n                                }\n                                tag = stream.readByte();\n                            }\n                        }\n                        else if (tag === Tags.TagError) {\n                            if (mode >= ResultMode.Raw) {\n                                result.writeByte(Tags.TagError);\n                                result.write(reader.readRaw());\n                            }\n                            else {\n                                reader.reset();\n                                error = new Error(reader.readString());\n                            }\n                            tag = stream.readByte();\n                        }\n                        if ([Tags.TagEnd,\n                             Tags.TagResult,\n                             Tags.TagError].indexOf(tag) < 0) {\n                            reject(new Error('Wrong Response:\\r\\n' + BytesIO.toString(response)));\n                            return;\n                        }\n                        if (mode >= ResultMode.Raw) {\n                            if (mode === ResultMode.RawWithEndTag) {\n                                result.writeByte(Tags.TagEnd);\n                            }\n                            batches[i].result = result.bytes;\n                        }\n                        else {\n                            batches[i].result = result;\n                        }\n                        batches[i].error = error;\n                    }\n                }\n                catch (e) {\n                    reject(e);\n                    return;\n                }\n                resolve(batches);\n            }, reject);\n        });\n    }\n\n    function beginBatch() {\n        _batch = true;\n    }\n\n    function endBatch(settings) {\n        settings = settings || {};\n        _batch = false;\n        if (_lock) {\n            return Future.promise(function(resolve, reject) {\n                _tasks.push({\n                    batch: true,\n                    settings: settings,\n                    resolve: resolve,\n                    reject: reject\n                });\n            });\n        }\n        var batchSize = _batches.length;\n        if (batchSize === 0) { return Future.value([]); }\n        var context = getBatchContext(settings);\n        if (context.sync) { _lock = true; }\n        var batches = _batches;\n        _batches = [];\n        var promise = Future.promise(function(resolve, reject) {\n            _batchInvokeHandler(batches, context).then(function(batches) {\n                batches.forEach(function(i) {\n                    if (i.error) {\n                        errorHandling(i.name, i.error, i.context, i.reject);\n                    }\n                    else {\n                        try {\n                            if (i.context.onsuccess) {\n                                try {\n                                    i.context.onsuccess(i.result, i.args);\n                                }\n                                catch (e) {\n                                    if (i.context.onerror) {\n                                        i.context.onerror(i.name, e);\n                                    }\n                                    i.reject(e);\n                                }\n                            }\n                            i.resolve(i.result);\n                        }\n                        catch (e) {\n                            i.reject(e);\n                        }\n                    }\n                    delete i.context;\n                    delete i.resolve;\n                    delete i.reject;\n                });\n                resolve(batches);\n            }, function(error) {\n                batches.forEach(function(i) {\n                    if ('reject' in i) {\n                        errorHandling(i.name, error, i.context, i.reject);\n                    }\n                });\n                reject(error);\n            });\n        });\n        promise.whenComplete(unlock(context.sync));\n        return promise;\n    }\n\n    // public methods\n    function getOnError() {\n        return _onerror;\n    }\n    function setOnError(value) {\n        if (typeof(value) === s_function) {\n            _onerror = value;\n        }\n    }\n    function getOnFailswitch() {\n        return _onfailswitch;\n    }\n    function setOnFailswitch(value) {\n        if (typeof(value) === s_function) {\n            _onfailswitch = value;\n        }\n    }\n    function getUri() {\n        return _uri;\n    }\n    function getUriList() {\n        return _uriList;\n    }\n    function setUriList(uriList) {\n        if (typeof(uriList) === s_string) {\n            _uriList = [uriList];\n        }\n        else if (Array.isArray(uriList)) {\n            _uriList = uriList.slice(0);\n            _uriList.sort(function() { return Math.random() - 0.5; });\n        }\n        else {\n            return;\n        }\n        _index = 0;\n        _uri = _uriList[_index];\n    }\n    function getFailswitch() {\n        return _failswitch;\n    }\n    function setFailswitch(value) {\n        _failswitch = !!value;\n    }\n    function getFailround() {\n        return _failround;\n    }\n    function getTimeout() {\n        return _timeout;\n    }\n    function setTimeout(value) {\n        if (typeof(value) === 'number') {\n            _timeout = value | 0;\n        }\n        else {\n            _timeout = 0;\n        }\n    }\n    function getRetry() {\n        return _retry;\n    }\n    function setRetry(value) {\n        if (typeof(value) === 'number') {\n            _retry = value | 0;\n        }\n        else {\n            _retry = 0;\n        }\n    }\n    function getIdempotent() {\n        return _idempotent;\n    }\n    function setIdempotent(value) {\n        _idempotent = !!value;\n    }\n    function setKeepAlive(value) {\n        _keepAlive = !!value;\n    }\n    function getKeepAlive() {\n        return _keepAlive;\n    }\n    function getByRef() {\n        return _byref;\n    }\n    function setByRef(value) {\n        _byref = !!value;\n    }\n    function getSimpleMode() {\n        return _simple;\n    }\n    function setSimpleMode(value) {\n        _simple = !!value;\n    }\n    function getUseHarmonyMap() {\n        return _useHarmonyMap;\n    }\n    function setUseHarmonyMap(value) {\n        _useHarmonyMap = !!value;\n    }\n    function setOption(option, value) {\n        _options[option] = value;\n    }\n    function getOptions() {\n        return _options;\n    }\n    function setOptions(options) {\n        for (var option in options) {\n            setOption(option, options[option]);\n        }\n    }\n    function getFilter() {\n        if (_filters.length === 0) {\n            return null;\n        }\n        if (_filters.length === 1) {\n            return _filters[0];\n        }\n        return _filters.slice();\n    }\n    function setFilter(filter) {\n        _filters.length = 0;\n        if (Array.isArray(filter)) {\n            filter.forEach(function(filter) {\n                addFilter(filter);\n            });\n        }\n        else {\n            addFilter(filter);\n        }\n    }\n    function addFilter(filter) {\n        if (filter &&\n            typeof filter.inputFilter === 'function' &&\n            typeof filter.outputFilter === 'function') {\n            _filters.push(filter);\n        }\n    }\n    function removeFilter(filter) {\n        var i = _filters.indexOf(filter);\n        if (i === -1) {\n            return false;\n        }\n        _filters.splice(i, 1);\n        return true;\n    }\n    function filters() {\n        return _filters;\n    }\n    function useService(uri, functions, create) {\n        if (create === undefined) {\n            if (typeof(functions) === s_boolean) {\n                create = functions;\n                functions = false;\n            }\n            if (!functions) {\n                if (typeof(uri) === s_boolean) {\n                    create = uri;\n                    uri = false;\n                }\n                else if (uri && uri.constructor === Object ||\n                         Array.isArray(uri)) {\n                    functions = uri;\n                    uri = false;\n                }\n            }\n        }\n        var stub = self;\n        if (create) {\n            stub = {};\n        }\n        if (!uri && !_uri) {\n            return new Error('You should set server uri first!');\n        }\n        if (uri) {\n            _uri = uri;\n        }\n        if (typeof(functions) === s_string ||\n            (functions && functions.constructor === Object)) {\n            functions = [functions];\n        }\n        if (Array.isArray(functions)) {\n            setFunctions(stub, functions);\n        }\n        else {\n            if (typeof(Proxy) === 'undefined' || !('create' in Proxy)) {\n                process.nextTick(initService, stub);\n                return _ready;\n            }\n            stub = Proxy.create(new HproseProxy(setFunction));\n        }\n        _ready.resolve(stub);\n        return stub;\n    }\n    function invoke(name, args, onsuccess/*, onerror, settings*/) {\n        var argc = arguments.length;\n        if ((argc < 1) || (typeof name !== s_string)) {\n            throw new Error('name must be a string');\n        }\n        if (argc === 1) { args = []; }\n        if (argc === 2) {\n            if (!Array.isArray(args)) {\n                var _args = [];\n                if (typeof args !== s_function) {\n                    _args.push(noop);\n                }\n                _args.push(args);\n                args = _args;\n            }\n        }\n        if (argc > 2) {\n            if (typeof onsuccess !== s_function) {\n                args.push(noop);\n            }\n            for (var i = 2; i < argc; i++) {\n                args.push(arguments[i]);\n            }\n        }\n        return _invoke(self, name, args, _batch);\n    }\n    function ready(onComplete, onError) {\n        return _ready.then(onComplete, onError);\n    }\n    function getTopic(name, id) {\n        if (_topics[name]) {\n            var topics = _topics[name];\n            if (topics[id]) {\n                return topics[id];\n            }\n        }\n        return null;\n    }\n    // subscribe(name, callback, timeout, failswitch)\n    // subscribe(name, id, callback, timeout, failswitch)\n    function subscribe(name, id, callback, timeout, failswitch) {\n        if (typeof name !== s_string) {\n            throw new TypeError('topic name must be a string.');\n        }\n        if (id === undefined || id === null) {\n            if (typeof callback === s_function) {\n                id = callback;\n            }\n            else {\n                throw new TypeError('callback must be a function.');\n            }\n        }\n        if (!_topics[name]) {\n            _topics[name] = Object.create(null);\n        }\n        if (typeof id === s_function) {\n            timeout = callback;\n            callback = id;\n            autoId().then(function(id) {\n                subscribe(name, id, callback, timeout, failswitch);\n            });\n            return;\n        }\n        if (typeof callback !== s_function) {\n            throw new TypeError('callback must be a function.');\n        }\n        if (Future.isPromise(id)) {\n            id.then(function(id) {\n                subscribe(name, id, callback, timeout, failswitch);\n            });\n            return;\n        }\n        if (timeout === undefined) { timeout = _timeout; }\n        var topic = getTopic(name, id);\n        if (topic === null) {\n            var cb = function() {\n                _invoke(self, name, [id, topic.handler, cb, {\n                    idempotent: true,\n                    failswitch: failswitch,\n                    timeout: timeout\n                }], false);\n            };\n            topic = {\n                handler: function(result) {\n                    var topic = getTopic(name, id);\n                    if (topic) {\n                        if (result !== null) {\n                            var callbacks = topic.callbacks;\n                            for (var i = 0, n = callbacks.length; i < n; ++i) {\n                                try {\n                                    callbacks[i](result);\n                                }\n                                catch (e) {}\n                            }\n                        }\n                        if (getTopic(name, id) !== null) { cb(); }\n                    }\n                },\n                callbacks: [callback]\n            };\n            _topics[name][id] = topic;\n            cb();\n        }\n        else if (topic.callbacks.indexOf(callback) < 0) {\n            topic.callbacks.push(callback);\n        }\n    }\n    function delTopic(topics, id, callback) {\n        if (topics) {\n            if (typeof callback === s_function) {\n                var topic = topics[id];\n                if (topic) {\n                    var callbacks = topic.callbacks;\n                    var p = callbacks.indexOf(callback);\n                    if (p >= 0) {\n                        callbacks[p] = callbacks[callbacks.length - 1];\n                        callbacks.length--;\n                    }\n                    if (callbacks.length === 0) {\n                        delete topics[id];\n                    }\n                }\n            }\n            else {\n                delete topics[id];\n            }\n        }\n    }\n    // unsubscribe(name)\n    // unsubscribe(name, callback)\n    // unsubscribe(name, id)\n    // unsubscribe(name, id, callback)\n    function unsubscribe(name, id, callback) {\n        if (typeof name !== s_string) {\n            throw new TypeError('topic name must be a string.');\n        }\n        if (id === undefined || id === null) {\n            if (typeof callback === s_function) {\n                id = callback;\n            }\n            else {\n                delete _topics[name];\n                return;\n            }\n        }\n        if (typeof id === s_function) {\n            callback = id;\n            id = null;\n        }\n        if (id === null) {\n            if (_id === null) {\n                if (_topics[name]) {\n                    var topics = _topics[name];\n                    for (id in topics) {\n                        delTopic(topics, id, callback);\n                    }\n                }\n            }\n            else {\n                _id.then(function(id) {\n                    unsubscribe(name, id, callback);\n                });\n            }\n        }\n        else if (Future.isPromise(id)) {\n            id.then(function(id) {\n                unsubscribe(name, id, callback);\n            });\n        }\n        else {\n            delTopic(_topics[name], id, callback);\n        }\n        if (isObjectEmpty(_topics[name])) {\n            delete _topics[name];\n        }\n    }\n    function isSubscribed(name) {\n        return !!_topics[name];\n    }\n    function subscribedList() {\n        var list = [];\n        for (var name in _topics) {\n            list.push(name);\n        }\n        return list;\n    }\n    function getId() {\n        return _id;\n    }\n    function autoId() {\n        if (_id === null) {\n            _id = _invoke(self, '#', [], false);\n        }\n        return _id;\n    }\n    autoId.sync = true;\n    autoId.idempotent = true;\n    autoId.failswitch = true;\n    function addInvokeHandler(handler) {\n        _invokeHandlers.push(handler);\n        _invokeHandler = _invokeHandlers.reduceRight(\n        function(next, handler) {\n            return function(name, args, context) {\n                return Future.toPromise(handler(name, args, context, next));\n            };\n        }, invokeHandler);\n    }\n    function addBatchInvokeHandler(handler) {\n        _batchInvokeHandlers.push(handler);\n        _batchInvokeHandler = _batchInvokeHandlers.reduceRight(\n        function(next, handler) {\n            return function(batches, context) {\n                return Future.toPromise(handler(batches, context, next));\n            };\n        }, batchInvokeHandler);\n    }\n    function addBeforeFilterHandler(handler) {\n        _beforeFilterHandlers.push(handler);\n        _beforeFilterHandler = _beforeFilterHandlers.reduceRight(\n        function(next, handler) {\n            return function(request, context) {\n                return Future.toPromise(handler(request, context, next));\n            };\n        }, beforeFilterHandler);\n    }\n    function addAfterFilterHandler(handler) {\n        _afterFilterHandlers.push(handler);\n        _afterFilterHandler = _afterFilterHandlers.reduceRight(\n        function(next, handler) {\n            return function(request, context) {\n                return Future.toPromise(handler(request, context, next));\n            };\n        }, afterFilterHandler);\n    }\n    function use(handler) {\n        addInvokeHandler(handler);\n        return self;\n    }\n    var batch = Object.create(null, {\n        begin: { value: beginBatch },\n        end: { value: endBatch },\n        use: { value: function(handler) {\n            addBatchInvokeHandler(handler);\n            return batch;\n        } }\n    });\n    var beforeFilter = Object.create(null, {\n        use: { value: function(handler) {\n            addBeforeFilterHandler(handler);\n            return beforeFilter;\n        } }\n    });\n    var afterFilter = Object.create(null, {\n        use: { value: function(handler) {\n            addAfterFilterHandler(handler);\n            return afterFilter;\n        } }\n    });\n    Object.defineProperties(this, {\n        '#': { value: autoId },\n        onerror: { get: getOnError, set: setOnError },\n        onfailswitch: { get: getOnFailswitch, set: setOnFailswitch },\n        uri: { get: getUri },\n        uriList: { get: getUriList, set: setUriList },\n        id: { get: getId },\n        failswitch: { get: getFailswitch, set: setFailswitch },\n        failround: { get: getFailround },\n        timeout: { get: getTimeout, set: setTimeout },\n        retry: { get: getRetry, set: setRetry },\n        idempotent: { get: getIdempotent, set: setIdempotent },\n        keepAlive: { get: getKeepAlive, set: setKeepAlive },\n        byref: { get: getByRef, set: setByRef },\n        simple: { get: getSimpleMode, set: setSimpleMode },\n        useHarmonyMap: { get: getUseHarmonyMap, set: setUseHarmonyMap },\n        options: { get: getOptions, set: setOptions },\n        setOption: { value: setOption },\n        filter: { get: getFilter, set: setFilter },\n        addFilter: { value: addFilter },\n        removeFilter: { value: removeFilter },\n        filters: { get: filters },\n        useService: { value: useService },\n        invoke: { value: invoke },\n        ready: { value: ready },\n        subscribe: {value: subscribe },\n        unsubscribe: {value: unsubscribe },\n        isSubscribed: { value : isSubscribed },\n        subscribedList: { value : subscribedList },\n        use: { value: use },\n        batch: { value: batch },\n        beforeFilter: { value: beforeFilter },\n        afterFilter: { value: afterFilter }\n    });\n    /* function constructor */ {\n        if ((settings) && (typeof settings === s_object)) {\n            ['failswitch', 'timeout', 'retry', 'idempotent',\n             'keepAlive', 'byref', 'simple','useHarmonyMap',\n             'filter', 'options'].forEach(function(key) {\n                 if (key in settings) {\n                     self[key] = settings[key];\n                 }\n            });\n        }\n        if (uri) {\n            setUriList(uri);\n            useService(functions);\n        }\n    }\n}\n\nfunction checkuri(uri) {\n    var protocol = parse(uri).protocol;\n    if (protocol === 'http:' ||\n        protocol === 'https:' ||\n        protocol === 'tcp:' ||\n        protocol === 'tcp4:'||\n        protocol === 'tcp6:' ||\n        protocol === 'tcps:' ||\n        protocol === 'tcp4s:' ||\n        protocol === 'tcp6s:' ||\n        protocol === 'tls:' ||\n        protocol === 'unix:' ||\n        protocol === 'ws:' ||\n        protocol === 'wss:') {\n        return;\n    }\n    throw new Error('The ' + protocol + ' client isn\\'t implemented.');\n}\n\nfunction create(uri, functions, settings) {\n    try {\n        return global.hprose.HttpClient.create(uri, functions, settings);\n    }\n    catch(e) {}\n    try {\n        return global.hprose.SocketClient.create(uri, functions, settings);\n    }\n    catch(e) {}\n    try {\n        return global.hprose.WebSocketClient.create(uri, functions, settings);\n    }\n    catch(e) {}\n    if (typeof uri === 'string') {\n        checkuri(uri);\n    }\n    else if (Array.isArray(uri)) {\n        uri.forEach(function(uri) { checkuri(uri); });\n        throw new Error('Not support multiple protocol.');\n    }\n    throw new Error('You should set server uri first!');\n}\n\nObject.defineProperty(Client, 'create', { value: create });\n\nutil.inherits(Client, EventEmitter);\n\nglobal.hprose.Client = Client;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/client/HttpClient.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/client/HttpClient.js                            *\n *                                                        *\n * Hprose Http Client for Node.js.                        *\n *                                                        *\n * LastModified: Dec 4, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar util = require('util');\nvar http = require('http');\nvar https = require('https');\nvar parse = require('url').parse;\nvar TimeoutError = require('../common/TimeoutError');\n\nvar Client = global.hprose.Client;\nvar BytesIO = global.hprose.BytesIO;\nvar Future = global.hprose.Future;\n\nfunction noop(){}\n\nvar s_cookieManager = {};\n\nfunction setCookie(headers, host) {\n    var name, values;\n    function _setCookie(value) {\n        var cookies, cookie, i;\n        cookies = value.replace(/(^\\s*)|(\\s*$)/g, '').split(';');\n        cookie = {};\n        value = cookies[0].replace(/(^\\s*)|(\\s*$)/g, '').split('=', 2);\n        if (value[1] === undefined) { value[1] = null; }\n        cookie.name = value[0];\n        cookie.value = value[1];\n        for (i = 1; i < cookies.length; i++) {\n            value = cookies[i].replace(/(^\\s*)|(\\s*$)/g, '').split('=', 2);\n            if (value[1] === undefined) { value[1] = null; }\n            cookie[value[0].toUpperCase()] = value[1];\n        }\n        // Tomcat can return SetCookie2 with path wrapped in \"\n        if (cookie.PATH) {\n            if (cookie.PATH.charAt(0) === '\"') {\n                cookie.PATH = cookie.PATH.substr(1);\n            }\n            if (cookie.PATH.charAt(cookie.PATH.length - 1) === '\"') {\n                cookie.PATH = cookie.PATH.substr(0, cookie.PATH.length - 1);\n            }\n        }\n        else {\n            cookie.PATH = '/';\n        }\n        if (cookie.EXPIRES) {\n            cookie.EXPIRES = Date.parse(cookie.EXPIRES);\n        }\n        if (cookie.DOMAIN) {\n            cookie.DOMAIN = cookie.DOMAIN.toLowerCase();\n        }\n        else {\n            cookie.DOMAIN = host;\n        }\n        cookie.SECURE = (cookie.SECURE !== undefined);\n        if (s_cookieManager[cookie.DOMAIN] === undefined) {\n            s_cookieManager[cookie.DOMAIN] = {};\n        }\n        s_cookieManager[cookie.DOMAIN][cookie.name] = cookie;\n    }\n    for (name in headers) {\n        values = headers[name];\n        name = name.toLowerCase();\n        if ((name === 'set-cookie') || (name === 'set-cookie2')) {\n            if (typeof(values) === 'string') {\n                values = [values];\n            }\n            values.forEach(_setCookie);\n        }\n    }\n}\n\nfunction getCookie(host, path, secure) {\n    var cookies = [];\n    for (var domain in s_cookieManager) {\n        if (host.indexOf(domain) > -1) {\n            var names = [];\n            for (var name in s_cookieManager[domain]) {\n                var cookie = s_cookieManager[domain][name];\n                if (cookie.EXPIRES && ((new Date()).getTime() > cookie.EXPIRES)) {\n                    names.push(name);\n                }\n                else if (path.indexOf(cookie.PATH) === 0) {\n                    if (((secure && cookie.SECURE) ||\n                         !cookie.SECURE) && (cookie.value !== null)) {\n                        cookies.push(cookie.name + '=' + cookie.value);\n                    }\n                }\n            }\n            for (var i in names) {\n                delete s_cookieManager[domain][names[i]];\n            }\n        }\n    }\n    if (cookies.length > 0) {\n        return cookies.join('; ');\n    }\n    return '';\n}\n\nfunction HttpClient(uri, functions, settings) {\n    if (this.constructor !== HttpClient) {\n        return new HttpClient(uri, functions, settings);\n    }\n    Client.call(this, uri, functions, settings);\n    var _header = Object.create(null);\n\n    var self = this;\n\n    function getRequestHeader(headers) {\n        var header = Object.create(null);\n        var name, value;\n        for (name in _header) {\n            header[name] = _header[name];\n        }\n        if (headers) {\n            for (name in headers) {\n                value = headers[name];\n                if (Array.isArray(value)) {\n                    header[name] = value.join(', ');\n                }\n                else {\n                    header[name] = value;\n                }\n            }\n        }\n        return header;\n    }\n\n    function send(request, future, context) {\n        request = BytesIO.toBuffer(request);\n        var options = parse(self.uri);\n        var protocol = options.protocol;\n        var client;\n        var secure;\n        if (protocol === 'http:') {\n            client = http;\n            secure = false;\n        }\n        else if (protocol === 'https:') {\n            client = https;\n            secure = true;\n        }\n        else {\n            throw new Error('Unsupported ' + protocol + ' protocol!');\n        }\n        options.keepAlive = self.keepAlive;\n        for (var key in self.options) {\n            options[key] = self.options[key];\n        }\n        options.method = 'POST';\n        options.headers = getRequestHeader(context.httpHeader);\n        options.headers['Content-Length'] = request.length;\n        var cookie = getCookie(options.host, options.path, secure);\n        if (cookie !== '') {\n            options.headers.Cookie = cookie;\n        }\n        var req = client.request(options, function(resp) {\n            context.httpHeader = resp.headers;\n            var bytes = new BytesIO();\n            resp.on('data', function(data) { bytes.write(data); });\n            resp.on('end', function() {\n                if (resp.statusCode === 200) {\n                    future.resolve(bytes.bytes);\n                }\n                else {\n                    future.reject(new Error(resp.statusCode + ':' + bytes.toString()));\n                }\n            });\n            resp.on('error', future.reject);\n            if (resp.statusCode === 200) {\n                setCookie(resp.headers, options.host);\n            }\n        });\n        req.on('error', future.reject);\n        req.end(request);\n        return req;\n    }\n\n    function sendAndReceive(request, context) {\n        var future = new Future();\n        var req = send(request, future, context);\n        if (context.timeout > 0) {\n            future = future.timeout(context.timeout).catchError(function(e) {\n                req.removeAllListeners('error');\n                req.on('error', noop);\n                req.abort();\n                throw e;\n            },\n            function(e) {\n                return e instanceof TimeoutError;\n            });\n        }\n        if (context.oneway) { future.resolve(); }\n        return future;\n    }\n\n    function setHeader(name, value) {\n        if (name.toLowerCase() !== 'content-type' &&\n            name.toLowerCase() !== 'content-length' &&\n            name.toLowerCase() !== 'host') {\n            if (value) {\n                _header[name] = value;\n            }\n            else {\n                delete _header[name];\n            }\n        }\n    }\n\n    Object.defineProperties(this, {\n        setHeader: { value: setHeader },\n        sendAndReceive: { value: sendAndReceive }\n    });\n}\n\nfunction checkuri(uri) {\n    var protocol = parse(uri).protocol;\n    if (protocol === 'http:' ||\n        protocol === 'https:') {\n        return;\n    }\n    throw new Error('This client desn\\'t support ' + protocol + ' scheme.');\n}\n\nfunction create(uri, functions, settings) {\n    if (typeof uri === 'string') {\n        checkuri(uri);\n    }\n    else if (Array.isArray(uri)) {\n        uri.forEach(function(uri) { checkuri(uri); });\n    }\n    else {\n        throw new Error('You should set server uri first!');\n    }\n    return new HttpClient(uri, functions, settings);\n}\n\nObject.defineProperty(HttpClient, 'create', { value: create });\n\nutil.inherits(HttpClient, Client);\n\nglobal.hprose.HttpClient = HttpClient;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/client/SocketClient.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/client/SocketClient.js                          *\n *                                                        *\n * Hprose Socket Client for Node.js.                      *\n *                                                        *\n * LastModified: Dec 2, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar util = require('util');\nvar net = require('net');\nvar tls = require('tls');\nvar parse = require('url').parse;\nvar TimeoutError = require('../common/TimeoutError');\n\nvar Client = global.hprose.Client;\nvar BytesIO = global.hprose.BytesIO;\nvar Future = global.hprose.Future;\n\nfunction setReceiveEvent(conn) {\n    var bytes = new BytesIO();\n    var headerLength = 4;\n    var dataLength = -1;\n    var id = null;\n    conn.on('data', function(chunk) {\n        bytes.write(chunk);\n        while (true) {\n            if ((dataLength < 0) && (bytes.length >= headerLength)) {\n                dataLength = bytes.readInt32BE();\n                if ((dataLength & 0x80000000) !== 0) {\n                    dataLength &= 0x7fffffff;\n                    headerLength = 8;\n                }\n            }\n            if ((headerLength === 8) && (id === null) && (bytes.length >= headerLength)) {\n                id = bytes.readInt32BE();\n            }\n            if ((dataLength >= 0) && ((bytes.length - headerLength) >= dataLength)) {\n                conn.emit('receive', bytes.read(dataLength), id);\n                headerLength = 4;\n                id = null;\n                bytes.trunc();\n                dataLength = -1;\n            }\n            else {\n                break;\n            }\n        }\n    });\n}\n\nfunction SocketTransporter(client) {\n    if (client) {\n        this.client = client;\n        this.uri = this.client.uri;\n        this.size = 0;\n        this.pool = [];\n        this.requests = [];\n    }\n}\n\nObject.defineProperties(SocketTransporter.prototype, {\n    create: { value: function() {\n        var client = this.client;\n        var parser = parse(this.uri);\n        var protocol = parser.protocol;\n        var socket;\n        var options = {};\n        for (var key in client.options) {\n            options[key] = client.options[key];\n        }\n        if (protocol === 'tcp:' ||\n            protocol === 'tcp4:' ||\n            protocol === 'tcp6:') {\n            socket = net;\n            options.host = parser.hostname;\n            options.port = parseInt(parser.port, 10);\n            if (protocol === 'tcp4:') {\n                options.family = 4;\n            }\n            else if (protocol === 'tcp6:') {\n                options.family = 6;\n            }\n        }\n        else if (protocol === 'tcps:' ||\n            protocol === 'tcp4s:' ||\n            protocol === 'tcp6s:' ||\n            protocol === 'tls:') {\n            socket = tls;\n            options.host = parser.hostname;\n            options.port = parseInt(parser.port, 10);\n            if (protocol === 'tcp4s:') {\n                options.family = 4;\n            }\n            else if (protocol === 'tcp6s:') {\n                options.family = 6;\n            }\n        }\n        else if (protocol === 'unix:') {\n            socket = net;\n            options.path = parser.path;\n        }\n        else {\n            throw new Error('Unsupported ' + protocol + ' protocol!');\n        }\n        var conn = socket.connect(options);\n        conn.setNoDelay(client.noDelay);\n        conn.setKeepAlive(client.keepAlive);\n        setReceiveEvent(conn);\n        var self = this;\n        conn.on('end', function() { conn.connected = false; });\n        conn.on('close', function() { conn.connected = false; --self.size; });\n        ++this.size;\n        return conn;\n    } }\n});\n\nfunction FullDuplexSocketTransporter(client) {\n    SocketTransporter.call(this, client);\n}\n\nFullDuplexSocketTransporter.prototype = Object.create(\n    SocketTransporter.prototype, {\n    fetch: { value: function() {\n        var pool = this.pool;\n        while (pool.length > 0) {\n            var conn = pool.pop();\n            if (conn.connected) {\n                if (conn.count === 0) {\n                    conn.removeAllListeners('timeout');\n                    conn.ref();\n                }\n                return conn;\n            }\n        }\n        return null;\n    } },\n    init: { value: function(conn) {\n        var self = this;\n        conn.count = 0;\n        conn.futures = {};\n        conn.timeoutIds = {};\n        conn.on('receive', function (data, id) {\n            var future = conn.futures[id];\n            if (future) {\n                self.clean(conn, id);\n                if (conn.count === 0) {\n                    self.recycle(conn);\n                }\n                future.resolve(data);\n            }\n        });\n        conn.on('error', function (e) {\n            var futures = conn.futures;\n            for (var id in futures) {\n                var future = futures[id];\n                self.clean(conn, id);\n                future.reject(e);\n            }\n            conn.destroy();\n        });\n    } },\n    recycle: { value: function(conn) {\n        conn.unref();\n        conn.setTimeout(this.client.poolTimeout, function() {\n            conn.connected = false;\n            conn.end();\n        });\n    } },\n    clean: { value: function(conn, id) {\n        if (conn.timeoutIds[id] !== undefined) {\n            global.clearTimeout(conn.timeoutIds[id]);\n            delete conn.timeoutIds[id];\n        }\n        delete conn.futures[id];\n        --conn.count;\n        this.sendNext(conn);\n    } },\n    sendNext: { value: function(conn) {\n        if (conn.count < 10) {\n            if (this.requests.length > 0) {\n                var request = this.requests.pop();\n                request.push(conn);\n                this.send.apply(this, request);\n            }\n            else {\n                if (this.pool.lastIndexOf(conn) < 0) {\n                    this.pool.push(conn);\n                }\n            }\n        }\n    } },\n    send: { value: function(request, future, id, context, conn) {\n        var self = this;\n\n        var timeout = context.timeout;\n        if (timeout > 0) {\n            conn.timeoutIds[id] = global.setTimeout(function() {\n                self.clean(conn, id);\n                if (conn.count === 0) {\n                    self.recycle(conn);\n                }\n                future.reject(new TimeoutError('timeout'));\n            }, timeout);\n        }\n        conn.count++;\n        conn.futures[id] = future;\n\n        var len = request.length;\n        var buf = new Buffer(8 + len);\n        buf.writeInt32BE(len | 0x80000000, 0);\n        buf.writeInt32BE(id, 4);\n        for (var i = 0; i < len; i++) {\n            buf[i + 8] = request[i];\n        }\n        conn.write(buf, function() {\n            self.sendNext(conn);\n        });\n    } },\n    getNextId: { value: function() {\n        return (this.nextid < 0x7fffffff) ? ++this.nextid : this.nextid = 0;\n    } },\n    sendAndReceive: { value: function(request, future, context) {\n        var conn = this.fetch();\n        var id = this.getNextId();\n        if (conn) {\n            this.send(request, future, id, context, conn);\n        }\n        else if (this.size < this.client.maxPoolSize) {\n            conn = this.create();\n            conn.on('error', function(e) {\n                conn.destroy();\n                future.reject(e);\n            });\n            var self = this;\n            conn.once('connect', function() {\n                conn.removeAllListeners('error');\n                conn.connected = true;\n                self.init(conn);\n                self.send(request, future, id, context, conn);\n            });\n        }\n        else {\n            this.requests.push([request, future, id, context]);\n        }\n    } }\n});\n\nFullDuplexSocketTransporter.prototype.constructor = SocketTransporter;\n\nfunction HalfDuplexSocketTransporter(client) {\n    SocketTransporter.call(this, client);\n}\n\nHalfDuplexSocketTransporter.prototype = Object.create(\n    SocketTransporter.prototype, {\n    fetch: { value: function() {\n        var pool = this.pool;\n        while (pool.length > 0) {\n            var conn = pool.pop();\n            if (conn.connected) {\n                conn.removeAllListeners('timeout');\n                conn.ref();\n                return conn;\n            }\n        }\n        return null;\n    } },\n    recycle: { value: function(conn) {\n        if (this.pool.lastIndexOf(conn) < 0) {\n            conn.unref();\n            conn.setTimeout(this.client.poolTimeout, function() {\n                conn.connected = false;\n                conn.end();\n            });\n            this.pool.push(conn);\n        }\n    } },\n    clean: { value: function(conn) {\n        conn.removeAllListeners('receive');\n        conn.removeAllListeners('error');\n        if (conn.timeoutId !== undefined) {\n            global.clearTimeout(conn.timeoutId);\n            delete conn.timeoutId;\n        }\n    } },\n    sendNext: { value: function(conn) {\n        if (this.requests.length > 0) {\n            var request = this.requests.pop();\n            request.push(conn);\n            this.send.apply(this, request);\n        }\n        else {\n            this.recycle(conn);\n        }\n    } },\n    send: { value: function(request, future, context, conn) {\n        var self = this;\n        var timeout = context.timeout;\n        if (timeout > 0) {\n            conn.timeoutId = global.setTimeout(function() {\n                self.clean(conn);\n                conn.connected = false;\n                conn.end();\n                future.reject(new TimeoutError('timeout'));\n            }, timeout);\n        }\n        conn.on('receive', function(data) {\n            self.clean(conn);\n            self.sendNext(conn);\n            future.resolve(data);\n        });\n        conn.on('error', function(e) {\n            self.clean(conn);\n            conn.destroy();\n            future.reject(e);\n        });\n\n        var len = request.length;\n        var buf = new Buffer(4 + len);\n        buf.writeInt32BE(len, 0);\n        for (var i = 0; i < len; i++) {\n            buf[i + 4] = request[i];\n        }\n        conn.write(buf);\n    } },\n    sendAndReceive: { value: function(request, future, context) {\n        var conn = this.fetch();\n        if (conn) {\n            this.send(request, future, context, conn);\n        }\n        else if (this.size < this.client.maxPoolSize) {\n            conn = this.create();\n            var self = this;\n            conn.on('error', function(e) {\n                conn.destroy();\n                future.reject(e);\n            });\n            conn.once('connect', function() {\n                conn.removeAllListeners('error');\n                conn.connected = true;\n                self.send(request, future, context, conn);\n            });\n        }\n        else {\n            this.requests.push([request, future, context]);\n        }\n    } }\n});\n\nHalfDuplexSocketTransporter.prototype.constructor = SocketTransporter;\n\nfunction SocketClient(uri, functions, settings) {\n    if (this.constructor !== SocketClient) {\n        return new SocketClient(uri, functions, settings);\n    }\n    Client.call(this, uri, functions, settings);\n\n    var self = this;\n    var _noDelay = true;\n    var _fullDuplex = false;\n    var _maxPoolSize = 10;\n    var _poolTimeout = 30000;\n    var fdtrans = null;\n    var hdtrans = null;\n\n    function getNoDelay() {\n        return _noDelay;\n    }\n\n    function setNoDelay(value) {\n        _noDelay = !!value;\n    }\n\n    function getFullDuplex() {\n        return _fullDuplex;\n    }\n\n    function setFullDuplex(value) {\n        _fullDuplex = !!value;\n    }\n\n    function getMaxPoolSize() {\n        return _maxPoolSize;\n    }\n\n    function setMaxPoolSize(value) {\n        if (typeof(value) === 'number') {\n            _maxPoolSize = value | 0;\n            if (_maxPoolSize < 1) {\n                _maxPoolSize = 10;\n            }\n        }\n        else {\n            _maxPoolSize = 10;\n        }\n    }\n\n    function getPoolTimeout() {\n        return _poolTimeout;\n    }\n\n    function setPoolTimeout(value) {\n        if (typeof(value) === 'number') {\n            _poolTimeout = value | 0;\n        }\n        else {\n            _poolTimeout = 0;\n        }\n    }\n\n    function sendAndReceive(request, context) {\n        var future = new Future();\n        if (_fullDuplex) {\n            if ((fdtrans === null) || (fdtrans.uri !== self.uri)) {\n                fdtrans = new FullDuplexSocketTransporter(self);\n            }\n            fdtrans.sendAndReceive(request, future, context);\n        }\n        else {\n            if ((hdtrans === null) || (hdtrans.uri !== self.uri)) {\n                hdtrans = new HalfDuplexSocketTransporter(self);\n            }\n            hdtrans.sendAndReceive(request, future, context);\n        }\n        if (context.oneway) { future.resolve(); }\n        return future;\n    }\n\n    Object.defineProperties(this, {\n        noDelay: { get: getNoDelay, set: setNoDelay },\n        fullDuplex: { get: getFullDuplex, set: setFullDuplex },\n        maxPoolSize: { get: getMaxPoolSize, set: setMaxPoolSize },\n        poolTimeout: { get: getPoolTimeout, set: setPoolTimeout },\n        sendAndReceive: { value: sendAndReceive }\n    });\n}\n\nfunction checkuri(uri) {\n    var protocol = parse(uri).protocol;\n    if (protocol === 'tcp:' ||\n        protocol === 'tcp4:'||\n        protocol === 'tcp6:' ||\n        protocol === 'tcps:' ||\n        protocol === 'tcp4s:' ||\n        protocol === 'tcp6s:' ||\n        protocol === 'tls:' ||\n        protocol === 'unix:') {\n        return;\n    }\n    throw new Error('This client desn\\'t support ' + protocol + ' scheme.');\n}\n\nfunction create(uri, functions, settings) {\n    if (typeof uri === 'string') {\n        checkuri(uri);\n    }\n    else if (Array.isArray(uri)) {\n        uri.forEach(function(uri) { checkuri(uri); });\n    }\n    else {\n        throw new Error('You should set server uri first!');\n    }\n    return new SocketClient(uri, functions, settings);\n}\n\nObject.defineProperty(SocketClient, 'create', { value: create });\n\nutil.inherits(SocketClient, Client);\n\nglobal.hprose.SocketClient = SocketClient;\nglobal.hprose.TcpClient = SocketClient;\nglobal.hprose.UnixClient = SocketClient;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/client/WebSocketClient.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n/**********************************************************\\\n *                                                        *\n * hprose/client/WebSocketClient.js                       *\n *                                                        *\n * Hprose WebSocket Client for HTML5.                     *\n *                                                        *\n * LastModified: Dec 2, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar util = require('util');\nvar parse = require('url').parse;\n\n/*jshint -W079*/\nvar WebSocket = require('ws');\n\nvar Client = global.hprose.Client;\nvar BytesIO = global.hprose.BytesIO;\nvar Future = global.hprose.Future;\nvar TimeoutError = require('../common/TimeoutError');\n\nfunction WebSocketClient(uri, functions, settings) {\n    if (this.constructor !== WebSocketClient) {\n        return new WebSocketClient(uri, functions, settings);\n    }\n    Client.call(this, uri, functions, settings);\n\n    var _id = 0;\n    var _count = 0;\n    var _futures = [];\n    var _requests = [];\n    var _ready = null;\n    var ws = null;\n\n    var self = this;\n\n    function getNextId() {\n        return (_id < 0x7fffffff) ? ++_id : _id = 0;\n    }\n\n    function send(id, request) {\n        var bytes = new BytesIO();\n        bytes.writeInt32BE(id);\n        if (request.constructor === String) {\n            bytes.writeString(request);\n        }\n        else {\n            bytes.write(request);\n        }\n        var future = _futures[id];\n        try {\n            ws.send(bytes.bytes);\n        }\n        catch (e) {\n            future.reject(e);\n        }\n    }\n    function onopen() {\n        _ready.resolve();\n    }\n    function onmessage(data) {\n        var bytes = new BytesIO(data);\n        var id = bytes.readInt32BE();\n        var future = _futures[id];\n        delete _futures[id];\n        if (future !== undefined) {\n            --_count;\n            future.resolve(bytes.read(bytes.length - 4));\n        }\n        if ((_count < 100) && (_requests.length > 0)) {\n            ++_count;\n            var request = _requests.pop();\n            _ready.then(function() { send(request[0], request[1]); });\n        }\n        if (_count === 0) {\n            if (!self.keepAlive) { close(); }\n        }\n    }\n    function onclose(code, message) {\n        onerror(new Error(code + ':' + message));\n        ws = null;\n    }\n    function onerror(error) {\n        _futures.forEach(function(future, id) {\n            future.reject(error);\n            delete _futures[id];\n        });\n        _count = 0;\n    }\n    function connect() {\n        _ready = new Future();\n        self.setOption('perMessageDeflate', false);\n        ws = new WebSocket(self.uri, self.options);\n        ws.on('open', onopen);\n        ws.on('message', onmessage);\n        ws.on('error', onerror);\n        ws.on('close', onclose);\n    }\n    function sendAndReceive(request, context) {\n        var id = getNextId();\n        var future = new Future();\n        _futures[id] = future;\n        if (context.timeout > 0) {\n            future = future.timeout(context.timeout).catchError(function(e) {\n                delete _futures[id];\n                --_count;\n                throw e;\n            },\n            function(e) {\n                return e instanceof TimeoutError;\n            });\n        }\n        if (ws === null ||\n            ws.readyState === WebSocket.CLOSING ||\n            ws.readyState === WebSocket.CLOSED) {\n            connect();\n        }\n        if (_count < 100) {\n            ++_count;\n            _ready.then(function() { send(id, request); });\n        }\n        else {\n            _requests.push([id, request]);\n        }\n        if (context.oneway) { future.resolve(); }\n        return future;\n    }\n    function close() {\n        if (ws !== null) {\n            ws.removeAllListeners('open');\n            ws.removeAllListeners('message');\n            ws.removeAllListeners('error');\n            ws.removeAllListeners('close');\n            ws.close();\n        }\n    }\n    Object.defineProperties(this, {\n        sendAndReceive: { value: sendAndReceive },\n        close: { value: close }\n    });\n}\n\nfunction checkuri(uri) {\n    var protocol = parse(uri).protocol;\n    if (protocol === 'ws:' ||\n        protocol === 'wss:') {\n        return;\n    }\n    throw new Error('This client desn\\'t support ' + protocol + ' scheme.');\n}\n\nfunction create(uri, functions, settings) {\n    if (typeof uri === 'string') {\n        checkuri(uri);\n    }\n    else if (Array.isArray(uri)) {\n        uri.forEach(function(uri) { checkuri(uri); });\n    }\n    else {\n        throw new Error('You should set server uri first!');\n    }\n    return new WebSocketClient(uri, functions, settings);\n}\n\nObject.defineProperty(WebSocketClient, 'create', { value: create });\n\nutil.inherits(WebSocketClient, Client);\n\nglobal.hprose.WebSocketClient = WebSocketClient;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/server/Service.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/server/Service.js                               *\n *                                                        *\n * Hprose Service for Node.js.                            *\n *                                                        *\n * LastModified: Dec 5, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar isError = require('../common/isError');\nvar TimeoutError = require('../common/TimeoutError');\nvar crypto = require('crypto');\n\nvar Future = global.hprose.Future;\nvar ResultMode = global.hprose.ResultMode;\nvar Tags = global.hprose.Tags;\nvar BytesIO = global.hprose.BytesIO;\nvar Reader = global.hprose.Reader;\nvar Writer = global.hprose.Writer;\n\nfunction callService(args, context) {\n    if (context.oneway) {\n        process.nextTick(function() {\n            try {\n                Future.toPromise(context.method.apply(context.scope, args));\n            }\n            catch (e) {}\n        });\n        if (context.async) {\n            args[args.length - 1](null);\n        }\n        return null;\n    }\n    return Future.toPromise(context.method.apply(context.scope, args));\n}\n\nfunction getFuncName(func, obj) {\n    var f = func.toString();\n    var funcname = f.substr(0, f.indexOf('(')).replace(/(^\\s*function\\*?\\s*)|(\\s*$)/ig, '');\n    if ((funcname === '') && obj) {\n        for (var name in obj) {\n            if (obj[name] === func) { return name; }\n        }\n    }\n    return funcname;\n}\n\nfunction getNextId() {\n    var result = new Future();\n    crypto.randomBytes(16, function(err, buf) {\n        if (err) {\n            result.reject(err);\n        }\n        else {\n            result.resolve(buf.toString('hex'));\n        }\n    });\n    return result;\n}\n\nfunction Service() {\n    EventEmitter.call(this);\n\n    var _calls                  = {},\n        _names                  = [],\n        _filters                = [],\n        _onBeforeInvoke         = null,\n        _onAfterInvoke          = null,\n        _onSendError            = null,\n        _timeout                = 120000,\n        _heartbeat              = 3000,\n        _errorDelay             = 10000,\n        _simple                 = false,\n        _debug                  = false,\n        _passContext            = false,\n        _topics                 = {},\n        _events                 = {},\n        _invokeHandler          = invokeHandler,\n        _beforeFilterHandler    = beforeFilterHandler,\n        _afterFilterHandler     = afterFilterHandler,\n        _invokeHandlers         = [],\n        _beforeFilterHandlers   = [],\n        _afterFilterHandlers    = [],\n\n        self = this;\n\n    function inputFilter(data, context) {\n        for (var i = _filters.length - 1; i >= 0; i--) {\n            data = _filters[i].inputFilter(data, context);\n        }\n        return data;\n    }\n\n    function outputFilter(data, context) {\n        for (var i = 0, n = _filters.length; i < n; i++) {\n            data = _filters[i].outputFilter(data, context);\n        }\n        return data;\n    }\n\n    function getBeforeInvoke() {\n        return _onBeforeInvoke;\n    }\n\n    function setBeforeInvoke(value) {\n        if (value === null || typeof value === 'function') {\n            _onBeforeInvoke = value;\n        }\n        else {\n            throw new Error('onBeforeInvoke must be a function or null.');\n        }\n    }\n\n    function getAfterInvoke() {\n        return _onAfterInvoke;\n    }\n\n    function setAfterInvoke(value) {\n        if (value === null || typeof value === 'function') {\n            _onAfterInvoke = value;\n        }\n        else {\n            throw new Error('onAfterInvoke must be a function or null.');\n        }\n    }\n\n    function getSendError() {\n        return _onSendError;\n    }\n\n    function setSendError(value) {\n        if (value === null || typeof value === 'function') {\n            _onSendError = value;\n        }\n        else {\n            throw new Error('onSendError must be a function or null.');\n        }\n    }\n\n    function sendError(error, context) {\n        if (!isError(error)) {\n            error = new Error(error);\n        }\n        try {\n            self.emit('sendError', error, context);\n            if (_onSendError !== null) {\n                var e = _onSendError(error, context);\n                if (isError(e)) {\n                    error = e;\n                }\n            }\n        }\n        catch(e) {\n            error = e;\n        }\n        var stream = new BytesIO();\n        var writer = new Writer(stream, true);\n        stream.writeByte(Tags.TagError);\n        writer.writeString(_debug ? error.stack : error.message);\n        return stream;\n    }\n\n    function endError(error, context) {\n        var stream = sendError(error, context);\n        stream.writeByte(Tags.TagEnd);\n        return stream.bytes;\n    }\n\n    function beforeInvoke(name, args, context) {\n        try {\n            self.emit('beforeInvoke', name, args, context.byref, context);\n            if (_onBeforeInvoke !== null) {\n                var value = _onBeforeInvoke(name, args, context.byref, context);\n                if (isError(value)) { throw value; }\n                if (Future.isPromise(value)) {\n                    return value.then(function(e) {\n                        if (isError(e)) { throw e; }\n                        return invoke(name, args, context);\n                    }).then(null, function(e) {\n                        return sendError(e, context);\n                    });\n                }\n            }\n            return invoke(name, args, context).then(null, function(e) {\n                return sendError(e, context);\n            });\n        }\n        catch (e) {\n            return sendError(e, context);\n        }\n    }\n\n    function invokeHandler(name, args, context) {\n        if (('*' in _calls) && (context.method === _calls['*'].method)) {\n            args = [name, args];\n        }\n        var passContext = context.passContext;\n        if (passContext === undefined) {\n            passContext = _passContext;\n        }\n        if (context.async) {\n            return Future.promise(function(resolve, reject) {\n                if (passContext) { args.push(context); }\n                args.push(function() {\n                    var args = arguments;\n                    switch (args.length) {\n                        case 0: resolve(undefined); break;\n                        case 1: {\n                            var result = args[0];\n                            if (isError(result)) {\n                                reject(result);\n                            }\n                            else {\n                                resolve(result);\n                            }\n                            break;\n                        }\n                        default: {\n                            var err = args[0];\n                            var result = args[1];\n                            if (err == null) {\n                                resolve(result);\n                            }\n                            else if (isError(err)) {\n                                reject(err);\n                            }\n                            else {\n                                resolve(err);\n                            }\n                            break;\n                        }\n                    }\n                });\n                callService(args, context);\n            });\n        }\n        else {\n            if (passContext) { args.push(context); }\n            return Future.toPromise(callService(args, context));\n        }\n    }\n\n    function invoke(name, args, context) {\n        return _invokeHandler(name, args, context).then(function(result) {\n            if (isError(result)) { throw result; }\n            return afterInvoke(name, args, context, result);\n        });\n    }\n\n    function afterInvoke(name, args, context, result) {\n        args = args.slice();\n        if (typeof (args[args.length - 1]) === 'function') {\n            args.length--;\n        }\n        if (args[args.length - 1] === context) {\n            args.length--;\n        }\n        self.emit('afterInvoke', name, args, context.byref, result, context);\n        if (_onAfterInvoke !== null) {\n            var value = _onAfterInvoke(name, args, context.byref, result, context);\n            if (isError(value)) { throw value; }\n            if (Future.isPromise(value)) {\n                return value.then(function(e) {\n                    if (isError(e)) { throw e; }\n                    return doOutput(args, context, result);\n                });\n            }\n        }\n        return doOutput(args, context, result);\n    }\n\n    function doOutput(args, context, result) {\n        var mode = context.mode;\n        var simple = context.simple;\n        if (simple === undefined) {\n            simple = _simple;\n        }\n        if (mode === ResultMode.RawWithEndTag || mode === ResultMode.Raw) {\n            return result;\n        }\n        var output = new BytesIO();\n        var writer = new Writer(output, simple);\n        output.writeByte(Tags.TagResult);\n        if (mode === ResultMode.Serialized) {\n            output.write(result);\n        }\n        else {\n            writer.reset();\n            writer.serialize(result);\n        }\n        if (context.byref) {\n            output.writeByte(Tags.TagArgument);\n            writer.reset();\n            writer.writeList(args);\n        }\n        return output.bytes;\n    }\n\n    function doInvoke(input, context) {\n        var results = [];\n        var reader = new Reader(input);\n        var tag;\n        do {\n            reader.reset();\n            var name = reader.readString();\n            var alias = name.toLowerCase();\n            var cc = {};\n            var key;\n            for (key in context) { cc[key] = context[key]; }\n            var call = _calls[alias] || _calls['*'];\n            if (call) {\n                for (key in call) { cc[key] = call[key]; }\n            }\n            var args = [];\n            cc.byref = false;\n            tag = input.readByte();\n            if (tag === Tags.TagList) {\n                reader.useHarmonyMap = cc.useHarmonyMap;\n                reader.reset();\n                args = reader.readListWithoutTag();\n                tag = input.readByte();\n                if (tag === Tags.TagTrue) {\n                    cc.byref = true;\n                    tag = input.readByte();\n                }\n            }\n            if (tag !== Tags.TagEnd &&\n                tag !== Tags.TagCall) {\n                throw new Error('Unknown tag: ' + tag + '\\r\\n' +\n                                         'with following data: ' + input.toString());\n            }\n            if (call) {\n                results.push(beforeInvoke(name, args, cc));\n            }\n            else {\n                results.push(sendError(new Error('Can\\'t find this function ' + name + '().'), cc));\n            }\n        } while (tag === Tags.TagCall);\n        return Future.reduce(results, function(output, result) {\n            output.write(result);\n            return output;\n        }, new BytesIO()).then(function(output) {\n            output.writeByte(Tags.TagEnd);\n            return output.bytes;\n        });\n    }\n\n    function doFunctionList() {\n        var stream = new BytesIO();\n        var writer = new Writer(stream, true);\n        stream.writeByte(Tags.TagFunctions);\n        writer.writeList(_names);\n        stream.writeByte(Tags.TagEnd);\n        return stream.bytes;\n    }\n\n    function delayError(e, context) {\n        var err = endError(e, context);\n        if (_errorDelay > 0) {\n            return Future.delayed(_errorDelay, err);\n        }\n        else {\n            return Promise.value(err);\n        }\n    }\n\n    function beforeFilterHandler(request, context) {\n        var response;\n        try {\n            request = inputFilter(request, context);\n            response = _afterFilterHandler(request, context).then(null, function(e) {\n                return delayError(e, context);\n            });\n        }\n        catch (e) {\n            response = delayError(e, context);\n        }\n        return response.then(function(value) {\n            return outputFilter(value, context);\n        });\n    }\n\n    function afterFilterHandler(request, context) {\n        try {\n            var input = new BytesIO(request);\n            switch (input.readByte()) {\n                case Tags.TagCall: return doInvoke(input, context);\n                case Tags.TagEnd: return Future.value(doFunctionList(context));\n                default: throw new Error('Wrong Request: \\r\\n' + BytesIO.toString(request));\n            }\n        }\n        catch (e) {\n            return Future.error(e);\n        }\n    }\n\n    function defaultHandle(request, context) {\n        context.clients = Object.create(null, {\n            idlist: { value: idlist },\n            exist: { value: exist },\n            broadcast: { value: broadcast },\n            multicast: { value: multicast },\n            unicast: { value: unicast },\n            push: { value: push }\n        });\n        return _beforeFilterHandler(request, context);\n    }\n\n    function getTimeout() {\n        return _timeout;\n    }\n\n    function setTimeout(value) {\n        if (typeof(value) === 'number') {\n            _timeout = value | 0;\n        }\n        else {\n            _timeout = 0;\n        }\n    }\n\n    function getHeartbeat() {\n        return _heartbeat;\n    }\n\n    function setHeartbeat(value) {\n        if (typeof(value) === 'number') {\n            _heartbeat = value | 0;\n        }\n        else {\n            _heartbeat = 0;\n        }\n    }\n\n    function getErrorDelay() {\n        return _errorDelay;\n    }\n\n    function setErrorDelay(value) {\n        if (typeof(value) === 'number') {\n            _errorDelay = value | 0;\n        }\n        else {\n            _errorDelay = 0;\n        }\n    }\n    function isDebugEnabled() {\n        return _debug;\n    }\n\n    function setDebugEnabled(value) {\n        _debug = !!value;\n    }\n\n     function getSimpleMode() {\n        return _simple;\n    }\n\n    function setSimpleMode(value) {\n        _simple = !!value;\n    }\n\n    function getPassContext() {\n       return _passContext;\n   }\n\n   function setPassContext(value) {\n       _passContext = !!value;\n   }\n\n    function getFilter() {\n        if (_filters.length === 0) {\n            return null;\n        }\n        return _filters[0];\n    }\n\n    function setFilter(filter) {\n        _filters.length = 0;\n        if (filter &&\n            typeof filter.inputFilter === 'function' &&\n            typeof filter.outputFilter === 'function') {\n            _filters.push(filter);\n        }\n    }\n\n    function addFilter(filter) {\n        if (filter &&\n            typeof filter.inputFilter === 'function' &&\n            typeof filter.outputFilter === 'function') {\n            _filters.push(filter);\n        }\n    }\n\n    function removeFilter(filter) {\n        var i = _filters.indexOf(filter);\n        if (i === -1) {\n            return false;\n        }\n        _filters.splice(i, 1);\n        return true;\n    }\n\n    function remove(alias) {\n        var name = alias.toLowerCase();\n        if (_calls[name]) {\n            var index = _name.indexOf(alias);\n            if (index >= 0) {\n                _name.splice(index, 1);\n            }\n            delete _calls[name];\n        }\n    }\n\n    function addFunction(func, alias, options) {\n        if (typeof(func) !== 'function') {\n            throw new Error('Argument func must be a function');\n        }\n        if ((options === undefined) && (typeof alias === 'object')) {\n            options = alias;\n            alias = null;\n        }\n        options = options || {};\n        if (options.mode === undefined) {\n            options.mode = ResultMode.Normal;\n        }\n        if (alias === undefined || alias === null || alias === '') {\n            alias = getFuncName(func);\n            if (alias === '') {\n                throw new Error('Need an alias');\n            }\n        }\n        if (typeof(alias) === 'string') {\n            var name = alias.toLowerCase();\n            if (_calls[name] === undefined) {\n                _names.push(alias);\n            }\n            _calls[name] = {\n                method: func,\n                scope: options.scope,\n                mode: options.mode,\n                simple: options.simple,\n                oneway: !!options.oneway,\n                async: !!options.async,\n                useHarmonyMap: !!options.useHarmonyMap,\n                passContext: options.passContext\n            };\n        }\n        else {\n            throw new Error('Argument alias must be a string');\n        }\n    }\n\n    function addAsyncFunction(func, alias, options) {\n        if ((options === undefined) && (typeof alias === 'object')) {\n            options = alias;\n            alias = null;\n        }\n        options = options || {};\n        options.async = true;\n        addFunction(func, alias, options);\n    }\n\n    function addMissingFunction(func, options) {\n        addFunction(func, '*', options);\n    }\n\n    function addAsyncMissingFunction(func, options) {\n        options = options || {};\n        options.async = true;\n        addMissingFunction(func, options);\n    }\n\n    function addFunctions(funcs, aliases, options) {\n        var i;\n        if ((options === undefined) && (typeof aliases === 'object')) {\n            options = aliases;\n            aliases = null;\n        }\n        if (aliases === undefined || aliases === null || aliases === '') {\n            for (i in funcs) {\n                addFunction(funcs[i], null, options);\n            }\n        }\n        else {\n            if (funcs.length !== aliases.length) {\n                throw new Error('The count of functions is not matched with aliases');\n            }\n            for (i in funcs) {\n                addFunction(funcs[i], aliases[i], options);\n            }\n        }\n    }\n\n    function addAsyncFunctions(funcs, aliases, options) {\n        if ((options === undefined) && (typeof aliases === 'object')) {\n            options = aliases;\n            aliases = null;\n        }\n        options = options || {};\n        options.async = true;\n        addFunctions(funcs, aliases, options);\n    }\n\n    function addMethod(method, obj, alias, options) {\n        if ((options === undefined) && (typeof alias === 'object')) {\n            options = alias;\n            alias = null;\n        }\n        if (obj === undefined || obj === null) {\n            addFunction(method, alias, options);\n            return;\n        }\n        if (typeof(method) !== 'function' &&\n            typeof(obj[method]) !== 'function') {\n                throw new Error('method or obj[method] must be a function');\n        }\n        options = options || {};\n        if (options.scope === undefined) {\n            options.scope = obj;\n        }\n        if (options.mode === undefined) {\n            options.mode = ResultMode.Normal;\n        }\n        if (alias === undefined || alias === null) {\n            switch(typeof(method)) {\n                case 'string':\n                    alias = method;\n                    method = obj[method];\n                    break;\n                case 'function':\n                    alias = getFuncName(method, obj);\n                    if (alias === '') {\n                        throw new Error('Need an alias');\n                    }\n                    break;\n                default:\n                    throw new Error('Need an alias');\n            }\n        }\n        if (typeof(alias) === 'string') {\n            var name = alias.toLowerCase();\n            if (_calls[name] === undefined) {\n                _names.push(alias);\n            }\n            _calls[name] = {\n                method: method,\n                scope: options.scope,\n                mode: options.mode,\n                simple: options.simple,\n                oneway: !!options.oneway,\n                async: !!options.async,\n                useHarmonyMap: !!options.useHarmonyMap,\n                passContext: options.passContext\n            };\n        }\n        else {\n            throw new Error('Argument alias must be a string');\n        }\n    }\n\n    function addAsyncMethod(method, obj, alias, options) {\n        if ((options === undefined) && (typeof alias === 'object')) {\n            options = alias;\n            alias = null;\n        }\n        options = options || {};\n        options.async = true;\n        addMethod(method, obj, alias, options);\n    }\n\n    function addMissingMethod(method, obj, options) {\n        addMethod(method, obj, '*', options);\n    }\n\n    function addAsyncMissingMethod(method, obj, options) {\n        options = options || {};\n        options.async = true;\n        addMissingMethod(method, obj, options);\n    }\n\n    function addMethods(methods, obj, aliases, options) {\n        if ((options === undefined) && (typeof aliases === 'object')) {\n            options = aliases;\n            aliases = null;\n        }\n        var i;\n        if (aliases === undefined || aliases === null || aliases === '') {\n            for (i in methods) {\n                addMethod(methods[i], obj, null, options);\n            }\n        }\n        else {\n            if (methods.length !== aliases.length) {\n                throw new Error('The count of methods is not matched with aliases');\n            }\n            for (i in methods) {\n                addMethod(methods[i], obj, aliases[i], options);\n            }\n        }\n    }\n\n    function addAsyncMethods(methods, obj, aliases, options) {\n        if ((options === undefined) && (typeof aliases === 'object')) {\n            options = aliases;\n            aliases = null;\n        }\n        options = options || {};\n        options.async = true;\n        addMethods(methods, obj, aliases, options);\n    }\n\n    function addInstanceMethods(obj, aliasPrefix, options) {\n        if ((options === undefined) && (typeof aliasPrefix === 'object')) {\n            options = aliasPrefix;\n            aliasPrefix = null;\n        }\n        var alias;\n        for (var name in obj) {\n            alias = (aliasPrefix ? aliasPrefix + '_' + name : name);\n            if (typeof(obj[name]) === 'function') {\n                addMethod(obj[name], obj, alias, options);\n            }\n        }\n    }\n\n    function addAsyncInstanceMethods(obj, aliasPrefix, options) {\n        if ((options === undefined) && (typeof aliasPrefix === 'object')) {\n            options = aliasPrefix;\n            aliasPrefix = null;\n        }\n        options = options || {};\n        options.async = true;\n        addInstanceMethods(obj, aliasPrefix, options);\n    }\n\n    function add() {\n        var args = arguments;\n        switch (args.length) {\n            case 1: {\n                if (typeof(args[0]) === 'function') {\n                    addFunction(args[0]);\n                }\n                else if (typeof(args[0]) === 'string') {\n                    addFunction(global[args[0]], args[0]);\n                }\n                else if (Array.isArray(args[0])) {\n                    addFunctions(args[0]);\n                }\n                else {\n                    addInstanceMethods(args[0]);\n                }\n                return;\n            }\n            case 2: {\n                if (typeof(args[0]) === 'function' &&\n                    typeof(args[1]) === 'string') {\n                    addFunction(args[0], args[1]);\n                }\n                else if (typeof(args[0]) === 'string' &&\n                         typeof(args[1]) === 'string') {\n                    addFunction(global[args[0]], args[1]);\n                }\n                else if (Array.isArray(args[0])) {\n                    if (Array.isArray(args[1])) {\n                        addFunctions(args[0], args[1]);\n                    }\n                    else {\n                        addMethods(args[0], args[1]);\n                    }\n                }\n                else if (typeof(args[1]) === 'string') {\n                    addInstanceMethods(args[0], args[1]);\n                }\n                return;\n            }\n            case 3: {\n                if (typeof(args[0]) === 'function' &&\n                    typeof(args[2]) === 'string' &&\n                    !args[1]) {\n                    addFunction(args[0], args[2]);\n                }\n                else if (typeof(args[0]) === 'string' &&\n                         typeof(args[2]) === 'string') {\n                    if (args[1]) {\n                        addMethod(args[0], args[1], args[2]);\n                    }\n                    else {\n                        addFunction(global[args[0]], args[2]);\n                    }\n                }\n                else if (Array.isArray(args[0])) {\n                    if (Array.isArray(args[2]) && !args[1]) {\n                        addFunctions(args[0], args[2]);\n                    }\n                    else {\n                        addMethods(args[0], args[1], args[2]);\n                    }\n                }\n                else {\n                    addInstanceMethods(args[0], args[1], args[2]);\n                }\n                return;\n            }\n        }\n        throw new Error('Wrong arguments');\n    }\n\n    function addAsync() {\n        var args = arguments;\n        switch (args.length) {\n            case 1: {\n                if (typeof(args[0]) === 'function') {\n                    addAsyncFunction(args[0]);\n                }\n                else if (typeof(args[0]) === 'string') {\n                    addAsyncFunction(global[args[0]], args[0]);\n                }\n                else if (Array.isArray(args[0])) {\n                    addAsyncFunctions(args[0]);\n                }\n                else {\n                    addAsyncInstanceMethods(args[0]);\n                }\n                return;\n            }\n            case 2: {\n                if (typeof(args[0]) === 'function' &&\n                    typeof(args[1]) === 'string') {\n                    addAsyncFunction(args[0], args[1]);\n                }\n                else if (typeof(args[0]) === 'string' &&\n                         typeof(args[1]) === 'string') {\n                    addAsyncFunction(global[args[0]], args[1]);\n                }\n                else if (Array.isArray(args[0])) {\n                    if (Array.isArray(args[1])) {\n                        addAsyncFunctions(args[0], args[1]);\n                    }\n                    else {\n                        addAsyncMethods(args[0], args[1]);\n                    }\n                }\n                else if (typeof(args[1]) === 'string') {\n                    addAsyncInstanceMethods(args[0], args[1]);\n                }\n                return;\n            }\n            case 3: {\n                if (typeof(args[0]) === 'function' &&\n                    typeof(args[2]) === 'string' &&\n                    !args[1]) {\n                    addAsyncFunction(args[0], args[2]);\n                }\n                else if (typeof(args[0]) === 'string' &&\n                         typeof(args[2]) === 'string') {\n                    if (args[1]) {\n                        addAsyncMethod(args[0], args[1], args[2]);\n                    }\n                    else {\n                        addAsyncFunction(global[args[0]], args[2]);\n                    }\n                }\n                else if (Array.isArray(args[0])) {\n                    if (Array.isArray(args[2]) && !args[1]) {\n                        addAsyncFunctions(args[0], args[2]);\n                    }\n                    else {\n                        addAsyncMethods(args[0], args[1], args[2]);\n                    }\n                }\n                else {\n                    addAsyncInstanceMethods(args[0], args[1], args[2]);\n                }\n                return;\n            }\n        }\n        throw new Error('Wrong arguments');\n    }\n\n    function getTopics(topic) {\n        if (!(topic in _topics)) {\n            throw new Error('topic \"' + topic + '\" is not published.');\n        }\n        return _topics[topic];\n    }\n    function delTimer(topics, id) {\n        var t = topics[id];\n        if ('timer' in t) {\n            global.clearTimeout(t.timer);\n            delete t.timer;\n        }\n    }\n    function offline(topics, topic, id) {\n        delTimer(topics, id);\n        var messages = topics[id].messages;\n        delete topics[id];\n        messages.forEach(function(message) {\n            message.detector.resolve(false);\n        });\n        if (_events[topic] instanceof EventEmitter) {\n            _events[topic].emit('unsubscribe', id, self);\n        }\n        else {\n            self.emit('unsubscribe', topic, id, self);\n        }\n    }\n    function setTimer(topics, topic, id) {\n        var t = topics[id];\n        if (!('timer' in t)) {\n            t.timer = global.setTimeout(function() {\n                offline(topics, topic, id);\n            }, t.heartbeat);\n        }\n    }\n    function resetTimer(topics, topic, id) {\n        delTimer(topics, id);\n        setTimer(topics, topic, id);\n    }\n    function setRequestTimer(topic, id, request, timeout) {\n        var topics = getTopics(topic);\n        if (timeout > 0) {\n            return request.timeout(timeout).catchError(function(e) {\n                if (e instanceof TimeoutError) {\n                    var checkoffline = function() {\n                        var t = topics[id];\n                        t.timer = global.setTimeout(\n                            checkoffline,\n                            t.heartbeat\n                        );\n                        if (t.count < 0) {\n                            offline(topics, topic, id);\n                        }\n                        else {\n                            t.count--;\n                        }\n                    };\n                    checkoffline();\n                }\n            });\n        }\n        return request;\n    }\n    function publish(topic, options) {\n        if (Array.isArray(topic)) {\n            topic.forEach(function(t) {\n                publish(t, options);\n            });\n            return;\n        }\n        options = options || {};\n        var events = (('events' in options) ? options.events : undefined),\n        timeout = (('timeout' in options) ? options.timeout : _timeout),\n        heartbeat = (('heartbeat' in options) ? options.heartbeat : _heartbeat);\n\n        _topics[topic] = {};\n        _events[topic] = events;\n        addFunction(function(id) {\n            var topics = getTopics(topic);\n            if (id in topics) {\n                if (topics[id].count < 0) {\n                    topics[id].count = 0;\n                }\n                var messages = topics[id].messages;\n                if (messages.length > 0) {\n                    var message = messages.shift();\n                    message.detector.resolve(true);\n                    resetTimer(topics, topic, id);\n                    return message.result;\n                }\n                else {\n                    delTimer(topics, id);\n                    topics[id].count++;\n                }\n            }\n            else {\n                topics[id] = { messages: [], count: 1, heartbeat: heartbeat };\n                process.nextTick(function() {\n                    if (_events[topic] instanceof EventEmitter) {\n                        _events[topic].emit('subscribe', id, self);\n                    }\n                    else {\n                        self.emit('subscribe', topic, id, self);\n                    }\n                });\n            }\n            if ('request' in topics[id]) {\n                topics[id].request.resolve(null);\n            }\n            var request = new Future();\n            request.whenComplete(function() { topics[id].count--; });\n            topics[id].request = request;\n            return setRequestTimer(topic, id, request, timeout);\n        }, topic);\n    }\n    function _push(topic, id, result) {\n        if (Future.isPromise(result)) {\n            var __push = function(result) {\n                return _push(topic, id, result);\n            }\n            return result.then(__push, __push);\n        }\n        var topics = getTopics(topic);\n        if (!(id in topics)) {\n            return Future.value(false);\n        }\n        if ('request' in topics[id]) {\n            topics[id].request.resolve(result);\n            delete topics[id].request;\n            setTimer(topics, topic, id);\n            return Future.value(true);\n        }\n        else {\n            var detector = new Future();\n            topics[id].messages.push({ detector: detector, result: result });\n            setTimer(topics, topic, id);\n            return detector;\n        }\n    }\n    function idlist(topic) {\n        return Object.keys(getTopics(topic));\n    }\n    function exist(topic, id) {\n        return id in getTopics(topic);\n    }\n    function broadcast(topic, result, callback) {\n        multicast(topic, idlist(topic), result, callback);\n    }\n    function multicast(topic, ids, result, callback) {\n        if (typeof callback !== 'function') {\n            ids.forEach(function(id) { _push(topic, id, result); });\n            return;\n        }\n        var sent = [];\n        var unsent = [];\n        var n = ids.length;\n        var count = n;\n        function check(id) {\n            return function(success) {\n                if (success) {\n                    sent.push(id);\n                }\n                else {\n                    unsent.push(id);\n                }\n                if (--count === 0) {\n                    callback(sent, unsent);\n                }\n            };\n        }\n        for (var i = 0; i < n; ++i) {\n            var id = ids[i];\n            if (id !== undefined) {\n                _push(topic, id, result).then(check(id));\n            }\n            else {\n                --count;\n            }\n        }\n    }\n    function unicast(topic, id, result, callback) {\n        var detector = _push(topic, id, result);\n        if (typeof callback === 'function') {\n            detector.then(callback);\n        }\n    }\n\n    // push(topic, result)\n    // push(topic, ids, result)\n    // push(topic, id, result)\n    function push(topic) {\n        var args = arguments;\n        var argc = args.length;\n        var id, result;\n        if (argc < 2 || argc > 3) {\n            throw new Error('Wrong number of arguments');\n        }\n        if (argc === 2) {\n            result = args[1];\n        }\n        else {\n            id = args[1];\n            result = args[2];\n        }\n        if (typeof id === 'undefined') {\n            var topics = getTopics(topic);\n            for (id in topics) { _push(topic, id, result); }\n        }\n        else if (Array.isArray(id)) {\n            id.forEach(function(id) { _push(topic, id, result); });\n        }\n        else {\n            _push(topic, id, result);\n        }\n    }\n    function addBeforeFilterHandler(handler) {\n        _beforeFilterHandlers.push(handler);\n        _beforeFilterHandler = _beforeFilterHandlers.reduceRight(\n        function(next, handler) {\n            return function(request, context) {\n                return Future.toPromise(handler(request, context, next));\n            };\n        }, beforeFilterHandler);\n    }\n    function addAfterFilterHandler(handler) {\n        _afterFilterHandlers.push(handler);\n        _afterFilterHandler = _afterFilterHandlers.reduceRight(\n        function(next, handler) {\n            return function(request, context) {\n                return Future.toPromise(handler(request, context, next));\n            };\n        }, afterFilterHandler);\n    }\n    function addInvokeHandler(handler) {\n        _invokeHandlers.push(handler);\n        _invokeHandler = _invokeHandlers.reduceRight(\n        function(next, handler) {\n            return function(name, args, context) {\n                return Future.toPromise(handler(name, args, context, next));\n            };\n        }, invokeHandler);\n    }\n    function use(handler) {\n        addInvokeHandler(handler);\n        return self;\n    }\n    var beforeFilter = Object.create(null, {\n        use: { value: function(handler) {\n            addBeforeFilterHandler(handler);\n            return beforeFilter;\n        } }\n    });\n    var afterFilter = Object.create(null, {\n        use: { value: function(handler) {\n            addAfterFilterHandler(handler);\n            return afterFilter;\n        } }\n    });\n    addFunction(getNextId, '#', { simple: true } );\n\n    Object.defineProperties(this, {\n        doFunctionList: { value: doFunctionList },\n        defaultHandle: { value: defaultHandle },\n        endError: { value: endError },\n        onBeforeInvoke: { get: getBeforeInvoke, set: setBeforeInvoke },\n        onAfterInvoke: { get: getAfterInvoke, set: setAfterInvoke },\n        onSendError: { get: getSendError, set: setSendError },\n        timeout: { get: getTimeout, set: setTimeout },\n        heartbeat: { get: getHeartbeat, set: setHeartbeat },\n        debug: { get: isDebugEnabled, set: setDebugEnabled },\n        simple: { get: getSimpleMode, set: setSimpleMode },\n        passContext: { get: getPassContext, set: setPassContext },\n        errorDelay: { get: getErrorDelay, set: setErrorDelay },\n        filter: { get: getFilter, set: setFilter },\n        addFilter: { value: addFilter },\n        removeFilter: { value: removeFilter },\n        addFunction: { value: addFunction },\n        addAsyncFunction: { value: addAsyncFunction },\n        addMissingFunction: { value: addMissingFunction },\n        addAsyncMissingFunction: { value: addAsyncMissingFunction },\n        addFunctions: { value: addFunctions },\n        addAsyncFunctions: { value: addAsyncFunctions },\n        addMethod: { value: addMethod },\n        addAsyncMethod: { value: addAsyncMethod },\n        addMissingMethod: { value: addMissingMethod },\n        addAsyncMissingMethod: { value: addAsyncMissingMethod },\n        addMethods: { value: addMethods },\n        addAsyncMethods: { value: addAsyncMethods },\n        addInstanceMethods: { value: addInstanceMethods },\n        addAsyncInstanceMethods: { value: addAsyncInstanceMethods },\n        add: { value: add },\n        addAsync: { value: addAsync },\n        publish: { value: publish },\n        broadcast: { value: broadcast },\n        multicast: { value: multicast },\n        unicast: { value: unicast },\n        push: { value: push },\n        idlist: { value: idlist },\n        exist: { value: exist },\n        use: { value: use },\n        beforeFilter: { value: beforeFilter },\n        afterFilter: { value: afterFilter }\n    });\n}\n\nutil.inherits(Service, EventEmitter);\n\nglobal.hprose.Service = Service;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/common/isError.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/common/isError.js                               *\n *                                                        *\n * isError for Node.js.                                   *\n *                                                        *\n * LastModified: Sep 11, 2015                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\nvar objectToString = Object.prototype.toString;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar ERROR_TYPE = '[object Error]';\n\nfunction isError(err) {\n    if (err instanceof Error) {\n        return true;\n    }\n    if (typeof err !== 'object') {\n        return false;\n    }\n    while (err) {\n        if (objectToString.call(err) === ERROR_TYPE) {\n            return true;\n        }\n        err = getPrototypeOf(err);\n    }\n    return false;\n}\n\nmodule.exports = isError;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/server/HttpService.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/server/HttpService.js                           *\n *                                                        *\n * Hprose Http Service for Node.js.                       *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar fs = require('fs');\nvar util = require('util');\n\nvar Service = global.hprose.Service;\nvar BytesIO = global.hprose.BytesIO;\nvar Future = global.hprose.Future;\n\nfunction HttpService() {\n    Service.call(this);\n\n    var _onSendHeader = null;\n    var _crossDomain = true;\n    var _P3P = true;\n    var _get = true;\n    var _origins = {};\n    var _origincount = 0;\n    var _crossDomainXmlFile = null;\n    var _crossDomainXmlContent = null;\n    var _clientAccessPolicyXmlFile = null;\n    var _clientAccessPolicyXmlContent = null;\n    var _lastModified = (new Date()).toUTCString();\n    var _etag = '\"' + Math.floor(Math.random() * 2147483647).toString(16) +\n                ':' + Math.floor(Math.random() * 2147483647).toString(16) + '\"';\n\n    var self = this;\n\n    function getSendHeader() {\n        return _onSendHeader;\n    }\n\n    function setSendHeader(value) {\n        if (value === null || typeof value === 'function') {\n            _onSendHeader = value;\n        }\n        else {\n            throw new Error('onSendHeader must be a function or null.');\n        }\n    }\n\n    function crossDomainXmlHandler(request, response) {\n        if (request.url.toLowerCase() === '/crossdomain.xml') {\n            if (request.headers['if-modified-since'] === _lastModified &&\n                request.headers['if-none-match'] === _etag) {\n                response.statusCode = 304;\n            }\n            else {\n                response.setHeader('Last-Modified', _lastModified);\n                response.setHeader('Etag', _etag);\n                response.setHeader('Content-Type', 'text/xml');\n                response.setHeader('Content-Length', _crossDomainXmlContent.length);\n                response.write(_crossDomainXmlContent);\n            }\n            response.end();\n            return true;\n        }\n        return false;\n    }\n\n    function clientAccessPolicyXmlHandler(request, response) {\n        if (request.url.toLowerCase() === '/clientaccesspolicy.xml') {\n            if (request.headers['if-modified-since'] === _lastModified &&\n                request.headers['if-none-match'] === _etag) {\n                response.statusCode = 304;\n            }\n            else {\n                response.setHeader('Last-Modified', _lastModified);\n                response.setHeader('Etag', _etag);\n                response.setHeader('Content-Type', 'text/xml');\n                response.setHeader('Content-Length', _clientAccessPolicyXmlContent.length);\n                response.write(_clientAccessPolicyXmlContent);\n            }\n            response.end();\n            return true;\n        }\n        return false;\n    }\n\n    function sendHeader(context) {\n        var resp = context.response;\n        resp.setHeader('Content-Type', 'text/plain');\n        if (_P3P) {\n            resp.setHeader('P3P',\n                'CP=\"CAO DSP COR CUR ADM DEV TAI PSA PSD IVAi IVDi ' +\n                'CONi TELo OTPi OUR DELi SAMi OTRi UNRi PUBi IND PHY ONL ' +\n                'UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE GOV\"');\n        }\n        if (_crossDomain) {\n            var origin = context.request.headers.origin;\n            if (origin && origin !== 'null') {\n                if (_origincount === 0 || _origins[origin]) {\n                    resp.setHeader('Access-Control-Allow-Origin', origin);\n                    resp.setHeader('Access-Control-Allow-Credentials', 'true');\n                }\n            }\n            else {\n                resp.setHeader('Access-Control-Allow-Origin', '*');\n            }\n        }\n        self.emit('sendHeader', context);\n        if (_onSendHeader !== null) {\n            _onSendHeader(context);\n        }\n    }\n\n    function isCrossDomainEnabled() {\n        return _crossDomain;\n    }\n\n    function setCrossDomainEnabled(value) {\n        _crossDomain = !!value;\n    }\n\n    function isP3PEnabled() {\n        return _P3P;\n    }\n\n    function setP3PEnabled(value) {\n        _P3P = !!value;\n    }\n\n    function isGetEnabled() {\n        return _get;\n    }\n\n    function setGetEnabled(value) {\n        _get = !!value;\n    }\n\n    function addAccessControlAllowOrigin(origin) {\n        if (!_origins[origin]) {\n            _origins[origin] = true;\n            _origincount++;\n        }\n    }\n\n    function removeAccessControlAllowOrigin(origin) {\n        if (_origins[origin]) {\n            delete _origins[origin];\n            _origincount--;\n        }\n    }\n\n    function getCrossDomainXmlFile() {\n        return _crossDomainXmlFile;\n    }\n\n    function setCrossDomainXmlFile(value) {\n        _crossDomainXmlFile = value;\n        _crossDomainXmlContent = fs.readFileSync(_crossDomainXmlFile);\n    }\n\n    function getCrossDomainXmlContent() {\n        return _crossDomainXmlContent;\n    }\n\n    function setCrossDomainXmlContent(value) {\n        _crossDomainXmlFile = null;\n        if (typeof(value) === 'string') { value = new Buffer(value); }\n        _crossDomainXmlContent = value;\n    }\n\n    function getClientAccessPolicyXmlFile() {\n        return _clientAccessPolicyXmlFile;\n    }\n\n    function setClientAccessPolicyXmlFile(value) {\n        _clientAccessPolicyXmlFile = value;\n        _clientAccessPolicyXmlContent = fs.readFileSync(_clientAccessPolicyXmlFile);\n    }\n\n    function getClientAccessPolicyXmlContent() {\n        return _clientAccessPolicyXmlContent;\n    }\n\n    function setClientAccessPolicyXmlContent(value) {\n        _clientAccessPolicyXmlFile = null;\n        if (typeof(value) === 'string') { value = new Buffer(value); }\n        _clientAccessPolicyXmlContent = value;\n    }\n\n    function _send(data, response) {\n        data = BytesIO.toBuffer(data);\n        response.setHeader('Content-Length', data.length);\n        response.end(data);\n    }\n\n    function send(data, response) {\n        if (Future.isFuture(data)) {\n            data.then(function(data) { _send(data, response); });\n        }\n        else {\n            _send(data, response);\n        }\n    }\n\n    function handle(request, response) {\n        var context = {\n            server: self.server,\n            request: request,\n            response: response,\n            socket: request.socket,\n            userdata: {}\n        };\n        request.socket.setTimeout(self.timeout);\n        var bytes = new BytesIO();\n        request.on('data', function(data) { bytes.write(data); });\n        request.on('end', function() {\n            if (_clientAccessPolicyXmlContent !== null && clientAccessPolicyXmlHandler(request, response)) { return; }\n            if (_crossDomainXmlContent !== null && crossDomainXmlHandler(request, response)) { return; }\n            try {\n                sendHeader(context);\n            }\n            catch (e) {\n                send(self.endError(e, context), response);\n                return;\n            }\n            var result = '';\n            if ((request.method === 'GET') && _get) {\n                result = self.doFunctionList(context);\n            }\n            else if (request.method === 'POST') {\n                result = self.defaultHandle(bytes.bytes, context);\n            }\n            send(result, response);\n        });\n    }\n\n    Object.defineProperties(this, {\n        onSendHeader: { get: getSendHeader, set: setSendHeader },\n        crossDomain: { get: isCrossDomainEnabled, set: setCrossDomainEnabled },\n        p3p: { get: isP3PEnabled, set: setP3PEnabled },\n        get: { get: isGetEnabled, set: setGetEnabled },\n        crossDomainXmlFile: { get: getCrossDomainXmlFile, set: setCrossDomainXmlFile },\n        crossDomainXmlContent: { get: getCrossDomainXmlContent, set: setCrossDomainXmlContent },\n        clientAccessPolicyXmlFile: { get: getClientAccessPolicyXmlFile, set: setClientAccessPolicyXmlFile },\n        clientAccessPolicyXmlContent: { get: getClientAccessPolicyXmlContent, set: setClientAccessPolicyXmlContent },\n        addAccessControlAllowOrigin: { value: addAccessControlAllowOrigin },\n        removeAccessControlAllowOrigin: { value: removeAccessControlAllowOrigin },\n        handle: { value: handle }\n    });\n}\n\nutil.inherits(HttpService, Service);\n\nglobal.hprose.HttpService = HttpService;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/server/HttpServer.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/server/HttpServer.js                            *\n *                                                        *\n * Hprose Http Server for Node.js.                        *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar util = require('util');\nvar http = require('http');\nvar https = require('https');\nvar HttpService = global.hprose.HttpService;\n\nfunction HttpServer(port, hostname, tlsOptions) {\n    HttpService.call(this);\n\n    var self = this;\n    var server = (tlsOptions ?\n        https.createServer(tlsOptions, self.handle) :\n        http.createServer(self.handle));\n\n    server.on('clientError', function (e, socket) {\n        var context = { server: server, socket: socket, userdata:{} };\n        try {\n            self.emit('sendError', e, context);\n            if (self.onSendError) {\n                self.onSendError(e, context);\n            }\n        }\n        catch(e) {}\n    });\n\n    function start() {\n        server.listen(port, hostname);\n    }\n    function stop() {\n        server.close();\n    }\n    function listen() {\n        server.listen.apply(server, arguments);\n    }\n    function close(callback) {\n        server.close(callback);\n    }\n\n    Object.defineProperties(this, {\n        server: { get: function () { return server; } },\n        start: { value: start },\n        stop: { value: stop },\n        listen: { value: listen },\n        close: { value: close }\n    });\n}\n\nutil.inherits(HttpServer, HttpService);\n\nglobal.hprose.HttpServer = HttpServer;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/server/SocketService.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/server/SocketService.js                         *\n *                                                        *\n * Hprose Socket Service for Node.js.                     *\n *                                                        *\n * LastModified: Sep 17, 2016                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar util = require('util');\n\nvar Service = global.hprose.Service;\nvar BytesIO = global.hprose.BytesIO;\nvar Future = global.hprose.Future;\n\nfunction noop() {}\n\nfunction SocketService() {\n    Service.call(this);\n\n    var _onAccept = null;\n    var _onClose = null;\n\n    var self = this;\n\n    function getAccept() {\n        return _onAccept;\n    }\n\n    function setAccept(value) {\n        if (value === null || typeof value === 'function') {\n            _onAccept = value;\n        }\n        else {\n            throw new Error('onAccept must be a function or null.');\n        }\n    }\n\n    function getClose() {\n        return _onClose;\n    }\n\n    function setClose(value) {\n        if (value === null || typeof value === 'function') {\n            _onClose = value;\n        }\n        else {\n            throw new Error('onClose must be a function or null.');\n        }\n    }\n\n    function _send(socket, data, id) {\n        var p = (id === null ? 4 : 8);\n        var n = data.length;\n        var buf = new Buffer(p + n);\n        if (p === 8) {\n            buf.writeInt32BE(n | 0x80000000, 0);\n            buf.writeInt32BE(id, 4);\n        }\n        else {\n            buf.writeUInt32BE(n, 0);\n        }\n        for (var i = 0; i < n; i++) {\n            buf[i + p] = data[i];\n        }\n        socket.write(buf);\n    }\n\n    function send(socket, data, id) {\n        if (Future.isFuture(data)) {\n            data.then(function(data) { _send(socket, data, id); });\n        }\n        else {\n            _send(socket, data, id);\n        }\n    }\n\n    function run(socket, data, id) {\n        var context = {\n            server: self.server,\n            socket: socket,\n            userdata: {}\n        };\n        data = self.defaultHandle(data, context);\n        send(socket, data, id);\n    }\n\n    function receive(socket) {\n        var bytes = new BytesIO();\n        var headerLength = 4;\n        var dataLength = -1;\n        var id = null;\n        socket.on('data', function(chunk) {\n            bytes.write(chunk);\n            while (true) {\n                if ((dataLength < 0) && (bytes.length >= headerLength)) {\n                    dataLength = bytes.readInt32BE();\n                    if ((dataLength & 0x80000000) !== 0) {\n                        dataLength &= 0x7fffffff;\n                        headerLength = 8;\n                    }\n                }\n                if ((headerLength === 8) && (id === null) && (bytes.length >= headerLength)) {\n                    id = bytes.readInt32BE();\n                }\n                if ((dataLength >= 0) && ((bytes.length - headerLength) >= dataLength)) {\n                    var data = bytes.read(dataLength);\n                    run(socket, data, id);\n                    bytes.trunc();\n                    dataLength = -1;\n                    headerLength = 4;\n                    id = null;\n                }\n                else {\n                    break;\n                }\n            }\n        });\n    }\n\n    function handle(socket) {\n        var context = {\n            server: self.server,\n            socket: socket,\n            userdata: {}\n        };\n        try {\n            self.emit('accept', context);\n            if (_onAccept) { _onAccept(context); }\n        }\n        catch(e) {\n            socket.end();\n            return;\n        }\n        socket.on('close', function() {\n            try {\n                self.emit('close', context);\n                if (_onClose) { _onClose(context); }\n            }\n            catch(e) {}\n        });\n        socket.on('end', noop);\n        socket.on('error', function(e) {\n            try {\n                if (e.code != \"EPIPE\") {\n                    self.emit('sendError', e, context);\n                    if (self.onSendError) {\n                        self.onSendError(e, context);\n                    }\n                }\n            }\n            catch(e) {}\n        });\n        socket.setTimeout(self.timeout);\n        receive(socket);\n    }\n    Object.defineProperties(this, {\n        onAccept: { get: getAccept, set: setAccept },\n        onClose: { get: getClose, set: setClose },\n        handle: { value: handle }\n    });\n}\n\nutil.inherits(SocketService, Service);\n\nglobal.hprose.SocketService = SocketService;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/server/SocketServer.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/server/SocketServer.js                          *\n *                                                        *\n * Hprose Socket Server for Node.js.                      *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar util = require('util');\nvar net = require('net');\nvar tls = require('tls');\nvar SocketService = global.hprose.SocketService;\n\nfunction SocketServer(options, tlsOptions) {\n    SocketService.call(this);\n    var self = this;\n    var server = (tlsOptions ?\n        tls.createServer(tlsOptions, self.handle) :\n        net.createServer(self.handle));\n\n    server.on('error', function (e) {\n        var context = { server: server, userdata:{} };\n        try {\n            self.emit('sendError', e, context);\n            if (self.onSendError) {\n                self.onSendError(e, context);\n            }\n        }\n        catch(e) {}\n    });\n\n    function start() {\n        server.listen(options);\n    }\n    function stop() {\n        server.close();\n    }\n    function listen() {\n        server.listen.apply(server, arguments);\n    }\n    function close(callback) {\n        server.close(callback);\n    }\n\n    Object.defineProperties(this, {\n        server: { get: function () { return server; } },\n        start: { value: start },\n        stop: { value: stop },\n        listen: { value: listen },\n        close: { value: close }\n    });\n\n}\n\nutil.inherits(SocketServer, SocketService);\n\nglobal.hprose.SocketServer = SocketServer;\nglobal.hprose.TcpServer = SocketServer;\nglobal.hprose.UnixServer = SocketServer;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/server/WebSocketService.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/server/WebSocketService.js                      *\n *                                                        *\n * Hprose WebSocket Service for Node.js.                  *\n *                                                        *\n * LastModified: Sep 30, 2016                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar util = require('util');\n\nvar HttpService = global.hprose.HttpService;\nvar BytesIO = global.hprose.BytesIO;\nvar Future = global.hprose.Future;\n\nfunction WebSocketService() {\n    HttpService.call(this);\n\n    var _onAccept = null;\n    var _onClose = null;\n\n    var self = this;\n\n    function getAccept() {\n        return _onAccept;\n    }\n\n    function setAccept(value) {\n        if (value === null || typeof value === 'function') {\n            _onAccept = value;\n        }\n        else {\n            throw new Error('onAccept must be a function or null.');\n        }\n    }\n\n    function getClose() {\n        return _onClose;\n    }\n\n    function setClose(value) {\n        if (value === null || typeof value === 'function') {\n            _onClose = value;\n        }\n        else {\n            throw new Error('onClose must be a function or null.');\n        }\n    }\n\n    function _send(ws, data, id) {\n        var bytes = new BytesIO();\n        bytes.writeInt32BE(id);\n        if (data.constructor === String) {\n            bytes.writeString(data);\n        }\n        else {\n            bytes.write(data);\n        }\n        try {\n            ws.send(bytes.bytes, {\n                binary: true,\n                compress: false\n            });\n        }\n        catch (e) {\n            ws.emit('error', e);\n        }\n    }\n\n    function send(ws, data, id) {\n        if (Future.isFuture(data)) {\n            data.then(function(data) { _send(ws, data, id); });\n        }\n        else {\n            _send(ws, data, id);\n        }\n    }\n\n    function wsHandle(ws) {\n        var context = {\n            httpserver: self.httpserver,\n            server: self.server,\n            websocket: ws,\n            socket: ws._socket,\n            userdata: {}\n        };\n        try {\n            self.emit('accept', context);\n            if (_onAccept) { _onAccept(context); }\n        }\n        catch(e) {\n            ws.close();\n            return;\n        }\n        ws.on('close', function() {\n            try {\n                self.emit('close',context);\n                if (_onClose) { _onClose(context); }\n            }\n            catch(e) {}\n        });\n        ws.on('error', function(e) {\n            try {\n                self.emit('sendError', e, context);\n                if (self.onSendError) {\n                    self.onSendError(e, context);\n                }\n            }\n            catch(e) {}\n        });\n        ws.on('message', function(data) {\n            var bytes = new BytesIO(data);\n            var id = bytes.readInt32BE();\n            var request = bytes.read(bytes.length - 4);\n            process.nextTick(function() {\n                var context = {\n                    httpserver: self.httpserver,\n                    server: self.server,\n                    websocket: ws,\n                    socket: ws._socket,\n                    userdata: {}\n                };\n                data = self.defaultHandle(request, context);\n                send(ws, data, id);\n            });\n        });\n    }\n    Object.defineProperties(this, {\n        onAccept: { get: getAccept, set: setAccept },\n        onClose: { get: getClose, set: setClose },\n        wsHandle: { value: wsHandle }\n    });\n}\n\nutil.inherits(WebSocketService, HttpService);\n\nglobal.hprose.WebSocketService = WebSocketService;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/server/WebSocketServer.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/server/WebSocketServer.js                       *\n *                                                        *\n * Hprose WebSocket Server for Node.js.                   *\n *                                                        *\n * LastModified: Aug 20, 2016                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar util = require('util');\nvar ws = require('ws');\nvar http = require('http');\nvar https = require('https');\nvar WebSocketService = global.hprose.WebSocketService;\n\nfunction WebSocketServer(options, tlsOptions, handler) {\n    WebSocketService.call(this);\n    var self = this;\n    if (!handler) handler = this.handle;\n    var httpserver = tlsOptions ?\n        https.createServer(tlsOptions, handler) :\n        http.createServer(handler);\n    var host = options.host;\n    var port = options.port;\n    delete options.host;\n    delete options.port;\n    options.server = httpserver;\n    options.perMessageDeflate = false;\n    var server = null;\n\n    function onerror(e, socket) {\n        var context = {\n            httpserver: httpserver,\n            server: self.server,\n            userdata:{}\n        };\n        if (socket) { context.socket = socket; }\n        try {\n            self.emit('sendError', e, context);\n            if (self.onSendError) {\n                self.onSendError(e, context);\n            }\n        }\n        catch(e) {}\n    }\n\n    httpserver.on('clientError', onerror);\n\n    function start() {\n        httpserver.listen(port, host);\n        server = new ws.Server(options);\n        server.on('connection', self.wsHandle);\n        server.on('error', onerror);\n    }\n    function stop() {\n        server.close();\n        httpserver.close();\n    }\n    function listen() {\n        httpserver.listen.apply(httpserver, arguments);\n        server = new ws.Server(options);\n        server.on('connection', self.wsHandle);\n        server.on('error', onerror);\n    }\n    function close(callback) {\n        server.close();\n        httpserver.close(callback);\n    }\n\n    Object.defineProperties(this, {\n        httpserver: { get: function () { return httpserver; } },\n        server: { get: function () { return server; } },\n        start: { value: start },\n        stop: { value: stop },\n        listen: { value: listen },\n        close: { value: close }\n    });\n}\n\nutil.inherits(WebSocketServer, WebSocketService);\n\nglobal.hprose.WebSocketServer = WebSocketServer;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/server/Server.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/server/Server.js                                *\n *                                                        *\n * Hprose Server for Node.js.                             *\n *                                                        *\n * LastModified: Aug 20, 2016                             *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar parse = require('url').parse;\nvar HttpServer = global.hprose.HttpServer;\nvar SocketServer = global.hprose.SocketServer;\nvar WebSocketServer = global.hprose.WebSocketServer;\n\nfunction create(uri, tlsOptions, handler) {\n    var parser = parse(uri);\n    var protocol = parser.protocol;\n    var options = {};\n    var port;\n    if (protocol === 'http:' ||\n        protocol === 'https:') {\n        port = parseInt(parser.port, 10);\n        if (!port) {\n            port = (protocol === 'http:' ? 80 : 443);\n        }\n        return new HttpServer(port, parser.hostname, tlsOptions);\n    }\n    if (protocol === 'tcp:' ||\n        protocol === 'tcp4:'||\n        protocol === 'tcp6:' ||\n        protocol === 'tcps:' ||\n        protocol === 'tcp4s:' ||\n        protocol === 'tcp6s:' ||\n        protocol === 'tls:') {\n        if (parser.hostname) {\n            options.host = parser.hostname;\n        }\n        if (parser.port) {\n            options.port = parseInt(parser.port, 10);\n        }\n        return new SocketServer(options, tlsOptions);\n    }\n    if (protocol === 'unix:') {\n        options.path = parser.path;\n        return new SocketServer(options, tlsOptions);\n    }\n    if (protocol === 'ws:' ||\n        protocol === 'wss:') {\n        port = parseInt(parser.port, 10);\n        if (!port) {\n            port = (protocol === 'http:' ? 80 : 443);\n        }\n        options.port = port;\n        options.host = parser.hostname;\n        if (parser.path) {\n            options.path = parser.path;\n        }\n        return new WebSocketServer(options, tlsOptions, handler);\n    }\n    throw new Error('The ' + protocol + ' server isn\\'t implemented.');\n}\n\nfunction Server(uri, tlsOptions, handler) {\n    return create(uri, tlsOptions, handler);\n}\n\nObject.defineProperty(Server, 'create', { value: create });\n\nglobal.hprose.Server = Server;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/filter/JSONRPCClientFilter.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/filter/JSONRPCClientFilter.js                   *\n *                                                        *\n * jsonrpc client filter for Node.js.                     *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar Tags = global.hprose.Tags;\nvar BytesIO = global.hprose.BytesIO;\nvar Writer = global.hprose.Writer;\nvar Reader = global.hprose.Reader;\nvar JSON = global.JSON;\n\nvar s_id = 1;\n\nfunction JSONRPCClientFilter(version) {\n    this.version = version || '2.0';\n}\n\nJSONRPCClientFilter.prototype.inputFilter = function inputFilter(data/*, context*/) {\n    var json = BytesIO.toString(data);\n    if (json.charAt(0) === '{') {\n        json = '[' + json + ']';\n    }\n    var responses = JSON.parse(json);\n    var stream = new BytesIO();\n    var writer = new Writer(stream, true);\n    for (var i = 0, n = responses.length; i < n; ++i) {\n        var response = responses[i];\n        if (response.error) {\n            stream.writeByte(Tags.TagError);\n            writer.writeString(response.error.message);\n        }\n        else {\n            stream.writeByte(Tags.TagResult);\n            writer.serialize(response.result);\n        }\n    }\n    stream.writeByte(Tags.TagEnd);\n    return stream.bytes;\n};\n\nJSONRPCClientFilter.prototype.outputFilter = function outputFilter(data/*, context*/) {\n    var requests = [];\n    var stream = new BytesIO(data);\n    var reader = new Reader(stream, false, false);\n    var tag = stream.readByte();\n    do {\n        var request = {};\n        if (tag === Tags.TagCall) {\n            request.method = reader.readString();\n            tag = stream.readByte();\n            if (tag === Tags.TagList) {\n                request.params = reader.readListWithoutTag();\n                tag = stream.readByte();\n            }\n            if (tag === Tags.TagTrue) {\n                tag = stream.readByte();\n            }\n        }\n        if (this.version === '1.1') {\n            request.version = '1.1';\n        }\n        else if (this.version === '2.0') {\n            request.jsonrpc = '2.0';\n        }\n        request.id = s_id++;\n        requests.push(request);\n    } while (tag === Tags.TagCall);\n    if (requests.length > 1) {\n        return JSON.stringify(requests);\n    }\n    return JSON.stringify(requests[0]);\n};\n\nglobal.hprose.JSONRPCClientFilter = JSONRPCClientFilter;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/filter/JSONRPCServiceFilter.js":"/**********************************************************\\\n|                                                          |\n|                          hprose                          |\n|                                                          |\n| Official WebSite: http://www.hprose.com/                 |\n|                   http://www.hprose.org/                 |\n|                                                          |\n\\**********************************************************/\n\n/**********************************************************\\\n *                                                        *\n * hprose/filter/JSONRPCServiceFilter.js                  *\n *                                                        *\n * jsonrpc service filter for Node.js.                    *\n *                                                        *\n * LastModified: Mar 3, 2016                              *\n * Author: Ma Bingyao <andot@hprose.com>                  *\n *                                                        *\n\\**********************************************************/\n\n'use strict';\n\nvar Tags = global.hprose.Tags;\nvar BytesIO = global.hprose.BytesIO;\nvar Writer = global.hprose.Writer;\nvar Reader = global.hprose.Reader;\nvar JSON = global.JSON;\n\nvar leftbrace   = 0x7B; //  '{'\nvar leftbracket = 0x5B; //  '['\n\nfunction JSONRPCServiceFilter() {}\n\nJSONRPCServiceFilter.prototype.inputFilter = function inputFilter(data, context) {\n    if (data.length > 0) {\n        if (data[0] === leftbracket || data[0] === leftbrace) {\n            var json = BytesIO.toString(data);\n            if (json.charAt(0) === '{') {\n                json = '[' + json + ']';\n            }\n            var requests;\n            try {\n                requests = JSON.parse(json);\n            }\n            catch (e) {\n                return data;\n            }\n            var bytes = new BytesIO();\n            var writer = new Writer(bytes, true);\n            context.userdata.jsonrpc = [];\n            for (var i = 0, n = requests.length; i < n; ++i) {\n                var jsonrpc = {};\n                var request = requests[i];\n                if (request.id === undefined) {\n                    jsonrpc.id = null;\n                }\n                else {\n                    jsonrpc.id = request.id;\n                }\n                if (request.version) {\n                    jsonrpc.version = request.version;\n                }\n                else if (request.jsonrpc) {\n                    jsonrpc.version = request.jsonrpc;\n                }\n                else {\n                    jsonrpc.version = '1.0';\n                }\n                context.userdata.jsonrpc[i] = jsonrpc;\n                if (request.method) {\n                    bytes.writeByte(Tags.TagCall);\n                    writer.writeString(request.method);\n                    if (request.params && request.params.length > 0) {\n                        writer.writeList(request.params);\n                    }\n                }\n            }\n            bytes.writeByte(Tags.TagEnd);\n            data = bytes.bytes;\n        }\n    }\n    return data;\n};\n\nJSONRPCServiceFilter.prototype.outputFilter = function outputFilter(data, context) {\n    if (context.userdata.jsonrpc) {\n        var jsonrpc = context.userdata.jsonrpc;\n        var responses = [];\n        var stream = new BytesIO(data);\n        var reader = new Reader(stream, false, false);\n        var tag = stream.readByte();\n        var i = 0;\n        do {\n            var response = {};\n            var version = jsonrpc[i].version;\n            if (version !== '2.0') {\n                if (version === '1.1') {\n                    response.version = '1.1';\n                }\n                response.result = null;\n                response.error = null;\n            }\n            else {\n                response.jsonrpc = '2.0';\n            }\n            response.id = jsonrpc[i].id;\n            if (tag === Tags.TagResult) {\n                reader.reset();\n                response.result = reader.unserialize();\n                tag = stream.readByte();\n            }\n            else if (tag === Tags.TagError) {\n                reader.reset();\n                response.error = {\n                    code: -1,\n                    message: reader.readString()\n                };\n                tag = stream.readByte();\n            }\n            responses[i++] = response;\n        } while (tag !== Tags.TagEnd);\n        if (responses.length === 1) {\n            responses = responses[0];\n        }\n        data = JSON.stringify(responses);\n    }\n    return data;\n};\n\nglobal.hprose.JSONRPCServiceFilter = JSONRPCServiceFilter;\n","/home/travis/build/npmtest/node-npmtest-hprose/node_modules/hprose/lib/utils/regenerator-runtime.js":"/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `value instanceof AwaitArgument` to determine if the yielded value is\n  // meant to be awaited. Some may consider the name of this method too\n  // cutesy, but they are curmudgeons.\n  runtime.awrap = function(arg) {\n    return new AwaitArgument(arg);\n  };\n\n  function AwaitArgument(arg) {\n    this.arg = arg;\n  }\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value instanceof AwaitArgument) {\n          return Promise.resolve(value.arg).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          if (method === \"return\" ||\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n            // A return or throw (when the delegate iterator has no throw\n            // method) always terminates the yield* loop.\n            context.delegate = null;\n\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            var returnMethod = delegate.iterator[\"return\"];\n            if (returnMethod) {\n              var record = tryCatch(returnMethod, delegate.iterator, arg);\n              if (record.type === \"throw\") {\n                // If the return method threw an exception, let that\n                // exception prevail over the original return or throw.\n                method = \"throw\";\n                arg = record.arg;\n                continue;\n              }\n            }\n\n            if (method === \"return\") {\n              // Continue with the outer return, now that the delegate\n              // iterator has been terminated.\n              continue;\n            }\n          }\n\n          var record = tryCatch(\n            delegate.iterator[method],\n            delegate.iterator,\n            arg\n          );\n\n          if (record.type === \"throw\") {\n            context.delegate = null;\n\n            // Like returning generator.throw(uncaught), but without the\n            // overhead of an extra function call.\n            method = \"throw\";\n            arg = record.arg;\n            continue;\n          }\n\n          // Delegate generator ran and handled its own exceptions so\n          // regardless of what the method was, we continue as if it is\n          // \"next\" with an undefined arg.\n          method = \"next\";\n          arg = undefined;\n\n          var info = record.arg;\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = arg;\n\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            method = \"next\";\n            arg = undefined;\n          }\n\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(arg) call above.\n          method = \"throw\";\n          arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.next = finallyEntry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n"}